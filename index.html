<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ArrayBox</title>
    <link rel="icon" id="favicon" href="assets/apl.png" type="image/png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Theme CSS with variables and syntax highlighting classes -->
    <link rel="stylesheet" href="src/theme.css">
    
    <style>
        /* App-specific styles (layout, components) */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--bg-gradient);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 35px;
        }

        .container {
            display: flex;
            gap: 18px;
            align-items: center;
            max-width: 875px;
            width: 100%;
            transition: transform 0.2s ease-out, max-width 0.05s ease-out, margin-left 0.25s ease-out;
        }

        .language-selector {
            position: relative;
        }

        .language-button {
            background: transparent;
            border: none;
            padding: 24px 37px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 24px;
            min-width: 184px;
            height: 135px;
            transition: opacity 0.2s;
        }

        .language-button:hover {
            opacity: 0.8;
        }

        .language-button img {
            width: 98px;
            height: 98px;
            object-fit: contain;
        }

        .language-button svg {
            width: 98px;
            height: 98px;
        }

        .dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 7px;
            background: #1f2937;
            border: 3px solid #4b5563;
            border-radius: 14px;
            box-shadow: 0 7px 21px var(--shadow-color);
            z-index: 1000;
            min-width: 333px;
            display: none;
        }

        .dropdown.show {
            display: block;
        }

        .dropdown-item {
            padding: 18px 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 18px;
            transition: background-color 0.2s;
            font-size: 23px;
            color: var(--text-color);
            white-space: nowrap;
        }

        .dropdown-item:hover {
            background-color: #374151;
        }

        .dropdown-item img {
            width: 42px;
            height: 42px;
            object-fit: contain;
        }

        .dropdown-item svg {
            width: 42px;
            height: 42px;
        }

        .dropdown-item .lang-name {
            font-weight: 500;
        }

        .dropdown-item .lang-version {
            color: #9CA3AF;
            font-size: 19px;
        }

        .input-container {
            flex: 1;
            position: relative;
        }

        .code-input {
            width: 100%;
            padding: 28px 35px;
            border: 3px solid #4b5563;
            border-radius: 14px;
            font-size: 42px;
            font-family: 'Courier New', monospace;
            transition: border-color 0.2s;
            min-height: 98px;
            background: #1f2937;
            color: var(--text-color);
            white-space: pre;
            overflow-x: auto;
            line-height: 1.5;
            caret-color: #10b981;
        }

        .code-input:focus {
            outline: none;
        }

        .code-input:empty:before {
            content: attr(data-placeholder);
            color: #6b7280;
            pointer-events: none;
        }

        .code-input.bqn {
            font-family: 'BQN', 'Courier New', monospace;
        }

        .code-input.uiua {
            font-family: 'Uiua', 'Courier New', monospace;
        }

        .code-input.j {
            font-family: 'JetBrains Mono', monospace;
            font-variant-ligatures: none;
        }

        .code-input.apl {
            font-family: 'APL', 'Courier New', monospace;
        }

        .code-input.kap {
            font-family: 'Kap', 'Courier New', monospace;
        }

        .code-input.tinyapl {
            font-family: 'TinyAPL', 'Courier New', monospace;
        }

        .output {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 24px;
            padding: 28px 35px;
            background: #1f2937;
            border: 3px solid #4b5563;
            border-radius: 14px;
            font-family: 'Courier New', monospace;
            font-size: 42px;
            white-space: pre;
            word-wrap: break-word;
            display: none;
            max-height: 919px;
            overflow-y: auto;
            overflow-x: hidden;
            color: var(--text-color);
            line-height: 1.5;
        }

        /* TinyAPL fancy array tables */
        .output table.tinyapl-vector,
        .output table.tinyapl-matrix,
        .output table.tinyapl-cube,
        .output table.tinyapl-dictionary,
        .output table.tinyapl-enclosure {
            border-collapse: collapse;
            display: inline-table;
            vertical-align: middle;
            margin: 4px;
            white-space: pre;
        }

        .output table.tinyapl-vector td,
        .output table.tinyapl-matrix td,
        .output table.tinyapl-cube td:not(.filler),
        .output table.tinyapl-dictionary td,
        .output table.tinyapl-enclosure td {
            border: 2px solid var(--text-color);
            padding: 4px 8px;
            text-align: right;
        }

        .output table table {
            margin: 3px;
        }

        .output .tinyapl-marker {
            position: relative;
            width: 0;
            height: 0;
            display: block;
        }
        .output .tinyapl-vector-marker::before {
            content: '‚Üí';
            position: absolute;
            top: -0.6em;
            left: 0.15em;
            font-size: 0.7em;
            color: #888;
        }
        .output .tinyapl-matrix-marker::before {
            content: '‚Üì';
            position: absolute;
            left: -0.5em;
            top: 0.1em;
            font-size: 0.7em;
            color: #888;
        }
        .output .tinyapl-cube-marker::before {
            content: '‚Üò';
            position: absolute;
            top: -0.6em;
            left: -0.5em;
            font-size: 0.7em;
            color: #888;
        }
        .output .tinyapl-dictionary-marker::before {
            content: ':';
            position: absolute;
            top: -0.7em;
            font-size: 0.7em;
            color: #888;
        }
        .output .tinyapl-enclosure-marker::before {
            content: '‚äÇ';
            position: absolute;
            top: -0.6em;
            font-size: 0.7em;
            color: #888;
        }

        .output .tinyapl-dictionary td:first-child {
            text-align: right;
        }

        .output .tinyapl-cube td.filler {
            border: none;
        }

        .output.bqn {
            font-family: 'BQN', 'Courier New', monospace;
        }

        .output.uiua {
            font-family: 'Uiua', 'Courier New', monospace;
        }

        .output.j {
            font-family: 'JetBrains Mono', monospace;
            font-variant-ligatures: none;
        }

        .output.apl {
            font-family: 'APL', 'Courier New', monospace;
        }

        .output.kap {
            font-family: 'Kap', 'Courier New', monospace;
        }

        .output.tinyapl {
            font-family: 'TinyAPL', 'Courier New', monospace;
        }

        .output.show {
            display: block;
        }

        .output.error {
            color: var(--error-color);
        }

        .bug-report-container {
            position: fixed;
            bottom: 28px;
            right: 35px;
            display: flex;
            align-items: center;
            gap: 14px;
        }

        .bug-report {
            font-family: 'JetBrains Mono', monospace;
            font-size: 24px;
            font-variant-ligatures: none;
            color: var(--border-hover);
            text-decoration: none;
            opacity: 0.6;
            transition: opacity 0.2s;
        }

        .bug-report:hover {
            opacity: 1;
            color: var(--text-color);
        }

        .bug-report-close {
            font-family: 'JetBrains Mono', monospace;
            font-size: 24px;
            font-variant-ligatures: none;
            color: var(--border-hover);
            background: none;
            border: none;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
            padding: 0;
        }

        .bug-report-container:hover .bug-report-close {
            opacity: 0.6;
        }

        .bug-report-close:hover {
            opacity: 1;
            color: var(--text-color);
        }

        .keyboard-hint {
            position: fixed;
            bottom: 35px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'JetBrains Mono', monospace;
            font-size: 23px;
            font-variant-ligatures: none;
            color: var(--text-color);
            opacity: 0.6;
            pointer-events: none;
            transition: opacity 0.5s ease-out;
            z-index: 100;
        }

        .keyboard-hint.hidden {
            opacity: 0;
        }

        /* Ctrl+Space primitive combo box */
        .primitive-combobox {
            position: absolute;
            background: #1f2937;
            border: 3px solid #4b5563;
            border-radius: 10px;
            box-shadow: 0 7px 21px var(--shadow-color);
            z-index: 10000;
            max-height: 400px;
            overflow: hidden;
            display: none;
            flex-direction: column;
        }

        .primitive-combobox.show {
            display: flex;
        }

        .primitive-combobox-header {
            padding: 18px 18px 18px 18px;
            border-bottom: 2px solid #374151;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-shrink: 0;
        }

        .primitive-combobox-input {
            flex: 1;
            font-family: 'JetBrains Mono', monospace;
            font-size: 20px;
            font-variant-ligatures: none;
            padding: 8px 14px;
            border: 2px solid #4b5563;
            border-radius: 7px;
            background: #111827;
            color: var(--text-color);
            outline: none;
        }

        .primitive-combobox-input:focus {
            border-color: #6b7280;
            outline: none;
        }

        .primitive-combobox-input::placeholder {
            color: #6b7280;
        }

        .primitive-combobox-hint {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            color: #6b7280;
        }

        .primitive-combobox-list {
            padding: 8px 0;
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }

        .primitive-combobox-item {
            padding: 10px 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 14px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 18px;
            transition: background-color 0.15s;
        }

        .primitive-combobox-item:hover,
        .primitive-combobox-item.selected {
            background-color: #374151;
        }

        .primitive-combobox-item.selected {
            border-left: 3px solid #22c55e;
            padding-left: 15px;
        }

        .primitive-combobox-glyph {
            font-size: 26px;
            min-width: 40px;
            text-align: center;
        }

        .primitive-combobox-glyph.bqn {
            font-family: 'BQN', 'Courier New', monospace;
        }

        .primitive-combobox-glyph.uiua {
            font-family: 'Uiua', 'Courier New', monospace;
        }

        .primitive-combobox-glyph.apl {
            font-family: 'APL', 'Courier New', monospace;
        }

        .primitive-combobox-glyph.kap {
            font-family: 'Kap', 'Courier New', monospace;
        }

        .primitive-combobox-glyph.tinyapl {
            font-family: 'TinyAPL', 'Courier New', monospace;
        }

        .primitive-combobox-name {
            flex: 1;
            color: var(--text-color);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .primitive-combobox-name em {
            font-style: normal;
            background: rgba(34, 197, 94, 0.3);
            border-radius: 3px;
            padding: 0 2px;
        }

        .primitive-combobox-shortcut {
            font-size: 14px;
            color: #9CA3AF;
            white-space: nowrap;
        }

        .primitive-combobox-shortcut kbd {
            background: #374151;
            border: 1px solid #4b5563;
            border-radius: 4px;
            padding: 2px 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
        }

        .primitive-combobox-empty {
            padding: 20px 18px;
            text-align: center;
            color: #6b7280;
            font-family: 'JetBrains Mono', monospace;
            font-size: 16px;
        }

        /* Help screen */
        .help-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-gradient);
            z-index: 10001;
            display: none;
            padding: 60px 80px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', monospace;
            font-variant-ligatures: none;
            justify-content: center;
            align-items: center;
        }

        .help-screen.show {
            display: flex;
        }

        .help-screen .help-header {
            color: #6b7280;
            font-size: 14px;
            margin-bottom: 50px;
            letter-spacing: 0.5px;
        }

        .help-screen .help-content {
            max-width: 600px;
        }

        .help-screen .help-section {
            margin-bottom: 40px;
        }

        .help-screen .help-section-title {
            color: #6b7280;
            font-size: 12px;
            text-transform: lowercase;
            letter-spacing: 1px;
            margin-bottom: 16px;
        }

        .help-screen .help-row {
            display: flex;
            align-items: baseline;
            margin-bottom: 10px;
            font-size: 14px;
            color: var(--text-color);
        }

        .help-screen .help-key {
            min-width: 160px;
            color: #9CA3AF;
        }

        .help-screen .help-desc {
            color: #9CA3AF;
        }

        .help-screen .help-footer {
            position: fixed;
            bottom: 40px;
            left: 80px;
            color: #4b5563;
            font-size: 12px;
        }

        /* F1 Documentation Tooltip - fixed position to right of editor */
        .f1-doc-tooltip {
            position: fixed;
            top: 50%;
            transform: translateY(-50%) translateX(35px);
            background: #1f2937;
            border: 2px solid #4b5563;
            border-radius: 14px;
            padding: 21px 24px;
            box-shadow: 0 7px 35px rgba(0, 0, 0, 0.5);
            width: 560px;
            max-width: 560px;
            max-height: 90vh;
            overflow-y: auto;
            font-family: 'JetBrains Mono', monospace;
            font-variant-ligatures: none;
            z-index: 10002;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease-out, visibility 0.2s ease-out, transform 0.25s ease-out;
        }

        .f1-doc-tooltip.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(-50%) translateX(0);
        }
        
        /* When F1 tooltip is shown, shift container left */
        body.f1-doc-active .container {
            margin-left: -600px;
        }

        .f1-doc-tooltip-header {
            display: flex;
            align-items: baseline;
            gap: 18px;
            margin-bottom: 14px;
            padding-bottom: 11px;
            border-bottom: 2px solid #374151;
        }

        .f1-doc-tooltip-glyph {
            font-size: 49px;
            line-height: 1;
        }

        .f1-doc-tooltip-type {
            font-family: 'JetBrains Mono', monospace;
            font-size: 16px;
            font-variant-ligatures: none;
            color: #9ca3af;
            text-transform: uppercase;
            letter-spacing: 0.9px;
            margin-left: auto;
            background: #374151;
            padding: 4px 11px;
            border-radius: 5px;
        }

        .f1-doc-tooltip-sig {
            font-family: 'JetBrains Mono', monospace;
            font-size: 18px;
            font-variant-ligatures: none;
            color: #60a5fa;
            margin-left: 14px;
            background: #1e3a5f;
            padding: 4px 11px;
            border-radius: 5px;
        }

        .f1-doc-tooltip-section {
            margin-bottom: 18px;
            padding-bottom: 14px;
            border-bottom: 2px solid #374151;
        }

        .f1-doc-tooltip-section:last-of-type {
            border-bottom: none;
            margin-bottom: 11px;
            padding-bottom: 0;
        }

        .f1-doc-tooltip-section-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 23px;
            font-weight: 600;
            font-variant-ligatures: none;
            color: #60a5fa;
            margin-bottom: 7px;
        }

        .f1-doc-tooltip-section-desc {
            font-family: 'JetBrains Mono', monospace;
            font-size: 19px;
            font-variant-ligatures: none;
            color: #d1d5db;
            line-height: 1.5;
        }

        .f1-doc-tooltip-title-line {
            font-family: 'JetBrains Mono', monospace;
            font-size: 23px;
            font-weight: 600;
            font-variant-ligatures: none;
            color: #e5e7eb;
            margin-bottom: 11px;
        }

        .f1-doc-tooltip-desc {
            font-family: 'JetBrains Mono', monospace;
            font-size: 21px;
            font-variant-ligatures: none;
            color: #d1d5db;
            line-height: 1.6;
            margin-bottom: 18px;
        }

        .f1-doc-tooltip-example {
            font-size: 21px;
            color: #e5e7eb;
            background: #111827;
            padding: 18px;
            border-radius: 7px;
            white-space: pre-wrap;
            overflow-x: auto;
            margin-bottom: 14px;
        }

        .f1-doc-tooltip-link {
            font-family: 'JetBrains Mono', monospace;
            font-size: 18px;
            font-variant-ligatures: none;
            color: var(--syntax-function);
            text-decoration: none;
            opacity: 0.7;
        }

        .f1-doc-tooltip-link:hover {
            opacity: 1;
            text-decoration: underline;
        }

        .f1-doc-tooltip-hint {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            color: #6b7280;
            margin-top: 14px;
            padding-top: 11px;
            border-top: 1px solid #374151;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="language-selector">
            <button class="language-button" id="languageButton" tabindex="2">
                <img id="currentLogo" src="assets/apl.png" alt="APL">
            </button>
            <div class="dropdown" id="dropdown">
                <div class="dropdown-item" data-lang="apl">
                    <img src="assets/apl.png" alt="APL">
                    <span class="lang-name">APL</span>
                    <span class="lang-version">Dyalog v20.0</span>
                </div>
                <div class="dropdown-item" data-lang="bqn">
                    <img src="assets/bqn.svg" alt="BQN">
                    <span class="lang-name">BQN</span>
                    <span class="lang-version">bqn.js</span>
                </div>
                <div class="dropdown-item" data-lang="uiua">
                    <img src="assets/uiua.png" alt="Uiua">
                    <span class="lang-name">Uiua</span>
                    <span class="lang-version" id="uiua-version">0.x</span>
                </div>
                <div class="dropdown-item" data-lang="j">
                    <img src="assets/j_logo.png" alt="J">
                    <span class="lang-name">J</span>
                    <span class="lang-version">J9.6</span>
                </div>
                <div class="dropdown-item" data-lang="kap">
                    <img src="assets/kap.png" alt="Kap">
                    <span class="lang-name">Kap</span>
                </div>
                <div class="dropdown-item" data-lang="tinyapl">
                    <img src="assets/tinyapl.svg" alt="TinyAPL">
                    <span class="lang-name">TinyAPL</span>
                    <span class="lang-version" id="tinyapl-version">0.13-beta</span>
                </div>
            </div>
        </div>
        <div class="input-container">
            <div 
                class="code-input apl" 
                id="codeInput" 
                contenteditable="true"
                data-placeholder="Have fun! ü•≥"
                spellcheck="false"
                tabindex="1"
            ></div>
            <div class="output" id="output"></div>
            <!-- Ctrl+Space primitive combo box -->
            <div class="primitive-combobox" id="primitiveCombobox">
                <div class="primitive-combobox-header">
                    <input type="text" class="primitive-combobox-input" id="comboboxInput" 
                           placeholder="Search primitives..." autocomplete="off" spellcheck="false">
                    <span class="primitive-combobox-hint">ESC to close</span>
                </div>
                <div class="primitive-combobox-list" id="comboboxList"></div>
            </div>
        </div>
    </div>
    
    <!-- F1 Documentation Tooltip - fixed position to right of editor -->
    <div class="f1-doc-tooltip" id="f1DocTooltip"></div>

    <div class="keyboard-hint" id="keyboardHint">ctrl+k keyboard ‚Ä¢ ctrl+h help</div>

    <!-- Help screen -->
    <div class="help-screen" id="helpScreen">
        <div class="help-inner">
            <div class="help-header">ctrl+h to close</div>
            <div class="help-content">
            <div class="help-section">
                <div class="help-section-title">box mode</div>
                <div class="help-row">
                    <span class="help-key">space or type</span>
                    <span class="help-desc">select array box</span>
                </div>
                <div class="help-row">
                    <span class="help-key">enter</span>
                    <span class="help-desc">evaluate code</span>
                </div>
                <div class="help-row">
                    <span class="help-key">shift + enter</span>
                    <span class="help-desc">insert newline</span>
                </div>
                <div class="help-row">
                    <span class="help-key">ctrl + ‚Üë / ‚Üì</span>
                    <span class="help-desc">switch language</span>
                </div>
                <div class="help-row">
                    <span class="help-key">ctrl + k</span>
                    <span class="help-desc">toggle keyboard overlay</span>
                </div>
                <div class="help-row">
                    <span class="help-key">ctrl + space</span>
                    <span class="help-desc">open primitive search</span>
                </div>
                <div class="help-row">
                    <span class="help-key">f1</span>
                    <span class="help-desc">show documentation for glyph at cursor</span>
                </div>
                <div class="help-row">
                    <span class="help-key">ctrl + l</span>
                    <span class="help-desc">create permalink (copy URL)</span>
                </div>
            </div>

            <div class="help-section">
                <div class="help-section-title">keyboard mode</div>
                <div class="help-row">
                    <span class="help-key">s or type</span>
                    <span class="help-desc">search primitives</span>
                </div>
                <div class="help-row">
                    <span class="help-key">‚Üë ‚Üì</span>
                    <span class="help-desc">navigate keys</span>
                </div>
                <div class="help-row">
                    <span class="help-key">shift</span>
                    <span class="help-desc">cycle through docs</span>
                </div>
            </div>
            </div>
        </div>
        <div class="help-footer">array box</div>
    </div>
    
    <div class="bug-report-container" id="bugReportContainer">
        <button class="bug-report-close" onclick="document.getElementById('bugReportContainer').style.display='none'" title="Hide">√ó</button>
        <a href="https://github.com/codereport/array-box/issues" target="_blank" class="bug-report">Report üêû</a>
    </div>

    <!-- BQN JavaScript implementation -->
    <script src="https://cdn.jsdelivr.net/gh/mlochbaum/BQN@master/docs/bqn.js"></script>

    <!-- Uiua WASM Loader -->
    <script type="module">
        // Load Uiua WASM module
        import initUiua, { eval_uiua, format_uiua, uiua_version } from './wasm/uiua_wasm.js';
        
        let uiuaReady = false;
        let uiuaLoadError = null;
        
        async function loadUiua() {
            if (uiuaReady) return true;
            if (uiuaLoadError) return false;
            
            try {
                await initUiua();
                uiuaReady = true;
                const version = uiua_version();
                console.log('Uiua WASM loaded, version:', version);
                // Update version display in dropdown
                const versionEl = document.getElementById('uiua-version');
                if (versionEl && version) {
                    versionEl.textContent = version;
                }
                return true;
            } catch (error) {
                console.warn('Uiua WASM loading failed:', error);
                uiuaLoadError = error;
                return false;
            }
        }
        
        // Expose to global scope for use in main script
        window.uiuaWasm = {
            load: loadUiua,
            isReady: () => uiuaReady,
            getError: () => uiuaLoadError,
            eval: (code) => {
                if (!uiuaReady) return null;
                const result = eval_uiua(code);
                return JSON.parse(result);
            },
            format: (code) => {
                if (!uiuaReady) return null;
                const result = format_uiua(code);
                return JSON.parse(result);
            },
            version: () => uiuaReady ? uiua_version() : null
        };
        
        // Pre-load Uiua when page loads
        loadUiua().catch(() => {});
    </script>

    <!-- TinyAPL WASM Loader -->
    <script type="module">
        // Load TinyAPL WASM module from local files
        let tinyaplReady = false;
        let tinyaplLoadError = null;
        let tinyaplModule = null;
        let tinyaplContext = null;
        let tinyaplLoading = false;
        let tinyaplLoadPromise = null;
        
        // Format TinyAPL result object to HTML tables (like TinyAPL's fancyShow)
        // Returns { isHtml: boolean, content: string }
        async function formatTinyaplResult(result, module, depth = 0) {
            // Helper to escape HTML
            function escapeHtml(str) {
                return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            }
            
            // Helper to format a scalar value
            async function formatScalar(v) {
                if (Array.isArray(v)) {
                    // Complex number [real, imag]
                    const [re, im] = v;
                    if (im === 0) return { isHtml: false, content: String(re) };
                    if (re === 0) {
                        const imStr = im === 1 ? '·¥ä' : im === -1 ? '¬Ø·¥ä' : `${im < 0 ? '¬Ø' : ''}${Math.abs(im)}·¥ä`;
                        return { isHtml: false, content: imStr };
                    }
                    return { isHtml: false, content: `${re < 0 ? '¬Ø' : ''}${Math.abs(re)}${im < 0 ? '¬Ø' : '+'}${Math.abs(im)}·¥ä` };
                }
                if (typeof v === 'string') {
                    return { isHtml: false, content: v.length === 1 ? v : `"${v}"` };
                }
                if (typeof v === 'object' && v && v.type) {
                    return await formatTinyaplResult(v, module, depth + 1);
                }
                return { isHtml: false, content: String(v) };
            }
            
            if (!result || typeof result !== 'object') {
                return { isHtml: false, content: String(result) };
            }
            
            // Limit recursion depth
            if (depth >= 6) {
                try {
                    return { isHtml: false, content: await module.show(result) };
                } catch (e) {
                    return { isHtml: false, content: JSON.stringify(result) };
                }
            }
            
            if (result.type === 'array') {
                const { shape, contents } = result;
                
                // Scalar - but check for enclosed arrays
                if (shape.length === 0) {
                    const v = contents[0];
                    // Check if this is an enclosed array (scalar containing array/dictionary)
                    if (typeof v === 'object' && v && (v.type === 'array' || v.type === 'dictionary')) {
                        const inner = await formatTinyaplResult(v, module, depth + 1);
                        let html = '<table class="tinyapl-enclosure"><div class="tinyapl-marker tinyapl-enclosure-marker"></div><tbody><tr>';
                        html += `<td>${inner.isHtml ? inner.content : escapeHtml(inner.content)}</td>`;
                        html += '</tr></tbody></table>';
                        return { isHtml: true, content: html };
                    }
                    return await formatScalar(v);
                }
                
                // String (1D array of chars)
                if (shape.length === 1 && contents.every(x => typeof x === 'string' && x.length === 1)) {
                    return { isHtml: false, content: contents.join('') };
                }
                
                // Vector (1D) - render as HTML table
                if (shape.length === 1 && contents.length > 0) {
                    const cells = await Promise.all(contents.map(formatScalar));
                    let html = '<table class="tinyapl-vector"><div class="tinyapl-marker tinyapl-vector-marker"></div><tbody><tr>';
                    for (const cell of cells) {
                        html += `<td>${cell.isHtml ? cell.content : escapeHtml(cell.content)}</td>`;
                    }
                    html += '</tr></tbody></table>';
                    return { isHtml: true, content: html };
                }
                
                // Matrix (2D) - render as HTML table
                if (shape.length === 2 && contents.length > 0) {
                    const [rows, cols] = shape;
                    const cells = await Promise.all(contents.map(formatScalar));
                    
                    let html = '<table class="tinyapl-matrix"><div class="tinyapl-marker tinyapl-vector-marker"></div><div class="tinyapl-marker tinyapl-matrix-marker"></div><tbody>';
                    for (let r = 0; r < rows; r++) {
                        html += '<tr>';
                        for (let c = 0; c < cols; c++) {
                            const idx = r * cols + c;
                            const cell = cells[idx];
                            html += `<td>${cell.isHtml ? cell.content : escapeHtml(cell.content)}</td>`;
                        }
                        html += '</tr>';
                    }
                    html += '</tbody></table>';
                    return { isHtml: true, content: html };
                }
                
                // Cube (3D) - render as HTML table with offset
                if (shape.length === 3 && contents.length > 0) {
                    const [a, b, c] = shape;
                    const cells = await Promise.all(contents.map(formatScalar));
                    
                    let html = '<table class="tinyapl-cube"><div class="tinyapl-marker tinyapl-vector-marker"></div><div class="tinyapl-marker tinyapl-matrix-marker"></div><div class="tinyapl-marker tinyapl-cube-marker"></div><tbody>';
                    for (let y = 0; y < a * b; y++) {
                        html += '<tr>';
                        for (let x = 0; x < c + a - 1; x++) {
                            const c0 = Math.floor(y / b);
                            const c1 = y % b;
                            const c2 = x - c0;
                            if (0 <= c0 && c0 < a && 0 <= c1 && c1 < b && 0 <= c2 && c2 < c) {
                                const idx = c0 * b * c + c1 * c + c2;
                                const cell = cells[idx];
                                html += `<td>${cell.isHtml ? cell.content : escapeHtml(cell.content)}</td>`;
                            } else {
                                html += '<td class="filler"></td>';
                            }
                        }
                        html += '</tr>';
                    }
                    html += '</tbody></table>';
                    return { isHtml: true, content: html };
                }
                
                // Higher rank - fall back to show
                try {
                    return { isHtml: false, content: await module.show(result) };
                } catch (e) {
                    return { isHtml: false, content: JSON.stringify(result) };
                }
            }
            
            // Dictionary
            if (result.type === 'dictionary') {
                if (!result.entries || result.entries.length === 0) {
                    return { isHtml: false, content: '‚ü®:‚ü©' };
                }
                let html = '<table class="tinyapl-dictionary"><div class="tinyapl-marker tinyapl-dictionary-marker"></div><tbody>';
                for (const [k, v] of result.entries) {
                    const key = await formatScalar(k);
                    const val = await formatScalar(v);
                    html += '<tr>';
                    html += `<td>${key.isHtml ? key.content : escapeHtml(key.content)}</td>`;
                    html += '<td>:</td>';
                    html += `<td>${val.isHtml ? val.content : escapeHtml(val.content)}</td>`;
                    html += '</tr>';
                }
                html += '</tbody></table>';
                return { isHtml: true, content: html };
            }
            
            // Function/adverb/conjunction - use show
            if (result.type === 'function' || result.type === 'adverb' || result.type === 'conjunction') {
                const repr = result.repr || await module.show(result);
                return { isHtml: false, content: repr };
            }
            
            // Fallback
            try {
                return { isHtml: false, content: await module.show(result) };
            } catch (e) {
                return { isHtml: false, content: JSON.stringify(result) };
            }
        }
        
        // Output buffers for capturing TinyAPL I/O
        let outputBuffer = '';
        let errorBuffer = '';
        
        async function loadTinyapl() {
            if (tinyaplReady) return true;
            if (tinyaplLoadError) return false;
            if (tinyaplLoading) return tinyaplLoadPromise;
            
            tinyaplLoading = true;
            tinyaplLoadPromise = (async () => {
                try {
                    console.log('[TinyAPL] Starting to load WASM module...');
                    
                    // Update version display to show loading
                    const versionEl = document.getElementById('tinyapl-version');
                    if (versionEl) {
                        versionEl.textContent = 'loading...';
                    }
                    
                    // Dynamically import the local TinyAPL module
                    console.log('[TinyAPL] Importing module...');
                    tinyaplModule = await import('./wasm/tinyapl/tinyapl.js');
                    console.log('[TinyAPL] Module imported, creating context...');
                    
                    // Create a context with I/O handlers
                    tinyaplContext = await tinyaplModule.newContext(
                        async () => '', // input - return empty for now
                        async (what) => { outputBuffer += what; }, // output
                        async (what) => { errorBuffer += what; }, // error
                        {} // quads - basic primitives only
                    );
                    
                    tinyaplReady = true;
                    tinyaplLoading = false;
                    console.log('[TinyAPL] WASM loaded successfully!');
                    
                    // Update version display in dropdown
                    if (versionEl) {
                        versionEl.textContent = '0.13-beta';
                    }
                    
                    return true;
                } catch (error) {
                    console.error('[TinyAPL] WASM loading failed:', error);
                    tinyaplLoadError = error;
                    tinyaplLoading = false;
                    
                    const versionEl = document.getElementById('tinyapl-version');
                    if (versionEl) {
                        versionEl.textContent = 'error';
                    }
                    
                    return false;
                }
            })();
            
            return tinyaplLoadPromise;
        }
        
        async function evalTinyapl(code) {
            // If not ready, try to wait for loading
            if (!tinyaplReady) {
                if (tinyaplLoadError) {
                    return {
                        success: false,
                        output: `TinyAPL failed to load: ${tinyaplLoadError.message}\n\nCheck browser console (F12) for details.`
                    };
                }
                
                // Wait for loading to complete (with timeout)
                const startWait = Date.now();
                const maxWait = 30000; // 30 second timeout
                
                while (!tinyaplReady && !tinyaplLoadError && (Date.now() - startWait) < maxWait) {
                    await new Promise(r => setTimeout(r, 100));
                }
                
                if (!tinyaplReady) {
                    if (tinyaplLoadError) {
                        return {
                            success: false,
                            output: `TinyAPL failed to load: ${tinyaplLoadError.message}\n\nCheck browser console (F12) for details.`
                        };
                    }
                    return {
                        success: false,
                        output: 'TinyAPL is still loading (7MB WASM file). Please wait a moment and try again.'
                    };
                }
            }
            
            // Reset output buffers
            outputBuffer = '';
            errorBuffer = '';
            
            try {
                // For multiline code, join lines with ‚ãÑ (statement separator)
                // Filter out empty lines and comment-only lines (‚çù comments out rest of line)
                const lines = code.split('\n')
                    .map(line => line.trim())
                    .filter(line => line && !line.startsWith('‚çù'))
                    .map(line => {
                        // Strip inline comments
                        const commentIndex = line.indexOf('‚çù');
                        return commentIndex >= 0 ? line.substring(0, commentIndex).trim() : line;
                    })
                    .filter(line => line);
                
                const processedCode = lines.length > 1 ? lines.join(' ‚ãÑ ') : (lines[0] || '');
                console.log('[TinyAPL] Processing code:', processedCode);
                
                // Run code
                const result = await tinyaplModule.runCode(tinyaplContext, processedCode);
                console.log('[TinyAPL] Raw result:', result);
                
                // Handle different result formats
                let value, success;
                
                if (Array.isArray(result)) {
                    // Expected format: [Value | Error, boolean]
                    [value, success] = result;
                } else if (result && typeof result === 'object') {
                    // Maybe it's an object with value/success properties
                    if ('success' in result) {
                        success = result.success;
                        value = result.value || result.error || result;
                    } else {
                        // Assume it's a successful value
                        success = true;
                        value = result;
                    }
                } else {
                    // Primitive value - assume success
                    success = true;
                    value = result;
                }
                
                // TinyAPL error patterns to detect in output
                const TINYAPL_ERROR_PATTERNS = [
                    /^(?:Syntax|Parse|Value|Domain|Rank|Length|Index|NYI|Internal|Invalid|Assertion) error:/im,
                    /does not exist$/im,
                    /not assigned$/im
                ];
                
                // Check errorBuffer for errors (errors from ‚éïERR go here)
                const hasErrorInBuffer = errorBuffer && TINYAPL_ERROR_PATTERNS.some(p => p.test(errorBuffer));
                
                if (success && !hasErrorInBuffer) {
                    // Format the raw result value directly (like TinyAPL's fancyShow)
                    let formatted;
                    try {
                        formatted = await formatTinyaplResult(value, tinyaplModule);
                    } catch (e) {
                        console.error('[TinyAPL] Format error:', e);
                        try {
                            formatted = { isHtml: false, content: await tinyaplModule.show(value) };
                        } catch (e2) {
                            formatted = { isHtml: false, content: String(value) };
                        }
                    }
                    
                    // Prepend any stdout output (from ‚éï‚Üê in user code)
                    let outputHtml = formatted.isHtml ? formatted.content : null;
                    // For plain text output, use tinyaplModule.show() if we got HTML
                    let output;
                    if (formatted.isHtml) {
                        try {
                            output = await tinyaplModule.show(value);
                        } catch (e) {
                            output = formatted.content; // fallback to HTML if show fails
                        }
                    } else {
                        output = formatted.content || '';
                    }
                    
                    if (outputBuffer) {
                        const prefix = outputBuffer.replace(/\n$/, '');
                        if (outputHtml) {
                            // For HTML output, escape and prepend stdout
                            outputHtml = prefix.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '<br>') + '<br>' + outputHtml;
                        }
                        output = prefix + '\n' + output;
                    }
                    
                    // Final check: look for error patterns in the formatted output
                    const hasErrorInOutput = TINYAPL_ERROR_PATTERNS.some(p => p.test(output));
                    if (hasErrorInOutput) {
                        return {
                            success: false,
                            output: output
                        };
                    }
                    
                    return {
                        success: true,
                        output: output,
                        outputHtml: outputHtml
                    };
                } else {
                    // Format the error
                    let errorMsg;
                    try {
                        errorMsg = await tinyaplModule.show(value);
                    } catch (e) {
                        errorMsg = typeof value === 'string' ? value : JSON.stringify(value);
                    }
                    return {
                        success: false,
                        output: errorBuffer + (errorBuffer ? '\n' : '') + errorMsg
                    };
                }
            } catch (error) {
                console.error('[TinyAPL] Execution error:', error);
                return {
                    success: false,
                    output: `TinyAPL execution error: ${error.message || String(error)}`
                };
            }
        }
        
        // Expose to global scope for use in main script
        window.tinyaplWasm = {
            load: loadTinyapl,
            isReady: () => tinyaplReady,
            getError: () => tinyaplLoadError,
            eval: evalTinyapl,
            version: () => tinyaplReady ? 'latest' : null
        };
        
        // Pre-load TinyAPL when page loads
        loadTinyapl().catch(() => {});
    </script>

    <!-- Main application module -->
    <script type="module">
        // Import from modular files
        import { createKeyboardHandler, bqnKeymap, aplKeymap, kapKeymap, tinyaplKeymap, tinyaplKeyboard, tinyaplGlyphs, uiuaGlyphs, jGlyphs, insertText } from './src/keymap.js?v=26';
        import { syntaxRules, highlightCode, escapeHtml, getSyntaxClass } from './src/syntax.js?v=26';
        import { ArrayKeyboard, uiuaGlyphNames, bqnGlyphNames, aplGlyphNames, kapGlyphNames, jGlyphNames, tinyaplGlyphNames, bqnGlyphDocs, uiuaGlyphDocs, jGlyphDocs, kapGlyphDocs, aplGlyphDocs, tinyaplGlyphDocs } from './src/keyboard.js?v=26';
        import { createEditorFeaturesManager } from './src/editor-features.js?v=1';
        import { translatePrimitives, clearTranslationCache } from './src/primitive-translate.js?v=2';
        
        // Glyph documentation by language
        const glyphDocsByLanguage = {
            apl: aplGlyphDocs,
            bqn: bqnGlyphDocs,
            uiua: uiuaGlyphDocs,
            j: jGlyphDocs,
            kap: kapGlyphDocs,
            tinyapl: tinyaplGlyphDocs
        };
        
        // Keyboard configurations for each language
        const keyboardConfigs = {
            bqn: {
                keymap: bqnKeymap,
                language: 'BQN',
                prefixKey: '\\',
                fontFamily: "'BQN', 'Courier New', monospace",
                syntaxRules: syntaxRules.bqn,
                displayMode: 'keyboard',
                glyphNames: bqnGlyphNames,
                glyphDocs: bqnGlyphDocs,
                logoPath: 'assets/bqn.svg',
                docLinks: {
                    layout: 'https://mlochbaum.github.io/BQN/keymap.html',
                    primitives: 'https://mlochbaum.github.io/BQN/doc/primitive.html',
                    syntax: 'https://mlochbaum.github.io/BQN/doc/syntax.html'
                }
            },
            apl: {
                keymap: aplKeymap,
                language: 'APL',
                prefixKey: '`',
                fontFamily: "'APL', 'Courier New', monospace",
                syntaxRules: syntaxRules.apl,
                displayMode: 'keyboard',
                glyphNames: aplGlyphNames,
                glyphDocs: aplGlyphDocs,
                logoPath: 'assets/apl.png',
                docLinks: {
                    layout: 'https://dfns.dyalog.com/n_keyboards.htm',
                    primitives: 'https://docs.dyalog.com/20.0/language-reference-guide/primitive-functions/',
                    syntax: 'https://docs.dyalog.com/20.0/language-reference-guide/other-syntax/'
                }
            },
            kap: {
                keymap: kapKeymap,
                language: 'Kap',
                prefixKey: '`',
                fontFamily: "'Kap', 'Courier New', monospace",
                syntaxRules: syntaxRules.kap,
                displayMode: 'keyboard',
                glyphNames: kapGlyphNames,
                glyphDocs: kapGlyphDocs,
                logoPath: 'assets/kap.png',
                docLinks: {
                    layout: 'https://kapdemo.dhsdevelopments.com/clientweb2/',
                    primitives: 'https://kapdemo.dhsdevelopments.com/reference.html',
                    syntax: 'https://kapdemo.dhsdevelopments.com/reference.html'
                }
            },
            uiua: {
                language: 'Uiua',
                fontFamily: "'Uiua', 'Courier New', monospace",
                syntaxRules: syntaxRules.uiua,
                displayMode: 'category',
                compactCategories: true,  // All glyphs inline with legend at bottom
                glyphNames: uiuaGlyphNames,  // Enable leader line labels
                glyphDocs: uiuaGlyphDocs,
                logoPath: 'assets/uiua.png',
                docLinks: {
                    primitives: 'https://www.uiua.org/docs#functions'
                },
                glyphCategories: {
                    stack: {
                        glyphs: uiuaGlyphs.stack,
                        label: 'Stack',
                        syntaxClass: 'syntax-stack'
                    },
                    monadicPervasive: {
                        glyphs: uiuaGlyphs.monadicPervasive,
                        label: 'Monadic Functions',
                        syntaxClass: 'syntax-uiua-function-monadic'
                    },
                    monadicArray: {
                        glyphs: uiuaGlyphs.monadicArray,
                        label: 'Monadic Functions',
                        syntaxClass: 'syntax-uiua-function-monadic',
                        isArray: true
                    },
                    dyadicPervasive: {
                        glyphs: uiuaGlyphs.dyadicPervasive,
                        label: 'Dyadic Functions',
                        syntaxClass: 'syntax-uiua-function-dyadic'
                    },
                    dyadicArray: {
                        glyphs: uiuaGlyphs.dyadicArray,
                        label: 'Dyadic Functions',
                        syntaxClass: 'syntax-uiua-function-dyadic',
                        isArray: true
                    },
                    monadicModifiers: {
                        glyphs: uiuaGlyphs.monadicModifiers,
                        label: '1-Modifiers',
                        syntaxClass: 'syntax-uiua-modifier-monadic'
                    },
                    dyadicModifiers: {
                        glyphs: uiuaGlyphs.dyadicModifiers,
                        label: '2-Modifiers',
                        syntaxClass: 'syntax-uiua-modifier-dyadic'
                    },
                    constants: {
                        glyphs: uiuaGlyphs.constants,
                        label: 'Constants',
                        syntaxClass: 'syntax-number'
                    }
                }
            },
            j: {
                language: 'J',
                fontFamily: "'JetBrains Mono', monospace",
                syntaxRules: syntaxRules.j,
                displayMode: 'category',
                compactCategories: true,  // All glyphs inline with legend at bottom
                categoryTitle: 'J Primitives',
                glyphNames: jGlyphNames,
                glyphDocs: jGlyphDocs,
                logoPath: 'assets/j_logo.png',
                docLinks: {
                    primitives: 'https://code.jsoftware.com/wiki/NuVoc'
                },
                glyphCategories: {
                    functions: {
                        glyphs: jGlyphs.functions,
                        label: 'Verbs',
                        syntaxClass: 'syntax-function'
                    },
                    verbDigraphs: {
                        glyphs: jGlyphs.verbDigraphs,
                        label: 'Verbs',
                        syntaxClass: 'syntax-function'
                    },
                    monadic: {
                        glyphs: jGlyphs.monadic,
                        label: 'Adverbs',
                        syntaxClass: 'syntax-modifier-monadic'
                    },
                    adverbDigraphs: {
                        glyphs: jGlyphs.adverbDigraphs,
                        label: 'Adverbs',
                        syntaxClass: 'syntax-modifier-monadic'
                    },
                    dyadic: {
                        glyphs: jGlyphs.dyadic,
                        label: 'Conjunctions',
                        syntaxClass: 'syntax-modifier-dyadic'
                    },
                    conjunctionDigraphs: {
                        glyphs: jGlyphs.conjunctionDigraphs,
                        label: 'Conjunctions',
                        syntaxClass: 'syntax-modifier-dyadic'
                    },
                    constants: {
                        glyphs: jGlyphs.constants,
                        label: 'Constants',
                        syntaxClass: 'syntax-number'
                    },
                    comments: {
                        glyphs: jGlyphs.comments,
                        label: 'Comments',
                        syntaxClass: 'syntax-comment'
                    }
                }
            },
            tinyapl: {
                keymap: tinyaplKeymap,
                language: 'TinyAPL',
                prefixKey: '`',
                fontFamily: "'TinyAPL', 'Courier New', monospace",
                syntaxRules: syntaxRules.tinyapl,
                displayMode: 'tinyapl',  // Special TinyAPL 4-glyph keyboard mode
                tinyaplKeyboard: tinyaplKeyboard,  // Full keyboard data with 4 prefix levels
                glyphNames: tinyaplGlyphNames,
                glyphDocs: tinyaplGlyphDocs,
                logoPath: 'assets/tinyapl.svg',
                docLinks: {
                    layout: 'https://beta.tinyapl.rubenverg.com/run/latest/',
                    primitives: 'https://beta.tinyapl.rubenverg.com/docs/primitive',
                }
            }
        };
        
        // Create the visual keyboard (initialized later)
        let visualKeyboard = null;
        
        // Check if keyboard should be shown for this language
        function languageSupportsKeyboard(lang) {
            return lang in keyboardConfigs;
        }
        
        // Update keyboard for current language
        function updateKeyboardForLanguage(lang) {
            if (!visualKeyboard) return;
            
            if (!languageSupportsKeyboard(lang)) {
                visualKeyboard.disable();
                return;
            }
            
            const config = keyboardConfigs[lang];
            if (!config) {
                visualKeyboard.disable();
                return;
            }
            
            // Check if display mode, language, glyphNames, glyphDocs, docLinks, logoPath, or tinyaplKeyboard changed - need to recreate overlay
            const modeChanged = visualKeyboard.displayMode !== (config.displayMode || 'keyboard');
            const languageChanged = visualKeyboard.language !== config.language;
            const glyphNamesChanged = visualKeyboard.glyphNames !== (config.glyphNames || null);
            const glyphDocsChanged = visualKeyboard.glyphDocs !== (config.glyphDocs || null);
            const docLinksChanged = JSON.stringify(visualKeyboard.docLinks) !== JSON.stringify(config.docLinks || null);
            const compactChanged = visualKeyboard.compactCategories !== (config.compactCategories || false);
            const logoChanged = visualKeyboard.logoPath !== (config.logoPath || null);
            const tinyaplKeyboardChanged = visualKeyboard.tinyaplKeyboard !== (config.tinyaplKeyboard || null);
            const needsRecreate = modeChanged || languageChanged || glyphNamesChanged || glyphDocsChanged || docLinksChanged || compactChanged || logoChanged || tinyaplKeyboardChanged;
            
            visualKeyboard.enable();
            visualKeyboard.keymap = config.keymap || {};
            visualKeyboard.language = config.language;
            visualKeyboard.prefixKey = config.prefixKey || '';
            visualKeyboard.fontFamily = config.fontFamily;
            visualKeyboard.syntaxRules = config.syntaxRules;
            visualKeyboard.displayMode = config.displayMode || 'keyboard';
            visualKeyboard.glyphCategories = config.glyphCategories || null;
            visualKeyboard.categoryTitle = config.categoryTitle || null;
            visualKeyboard.glyphNames = config.glyphNames || null;
            visualKeyboard.glyphDocs = config.glyphDocs || null;
            visualKeyboard.docLinks = config.docLinks || null;
            visualKeyboard.compactCategories = config.compactCategories || false;
            visualKeyboard.logoPath = config.logoPath || null;
            visualKeyboard.tinyaplKeyboard = config.tinyaplKeyboard || null;
            
            if (needsRecreate) {
                // Recreate the overlay for new display mode, language, or glyphNames
                visualKeyboard.recreateOverlay();
            }
            visualKeyboard.updateFont(config.fontFamily);
        }

        // Language configuration
        const languages = {
            bqn: {
                name: 'BQN',
                logo: 'assets/bqn.svg',
                fontClass: 'bqn',
                evaluate: (code) => {
                    const startTime = performance.now();
                    let result;
                    
                    // Helper to check if value is a single character
                    const isChar = (c) => typeof c === 'string' && c.length === 1;
                    
                    // Helper to check if value is a BQN character array (string)
                    const isCharArray = (arr) => Array.isArray(arr) && arr.length > 0 &&
                        arr.every(isChar);
                    
                    // Recursively find all character arrays (strings) in a nested structure
                    const findCharArrays = (val) => {
                        if (isCharArray(val)) return [val.join('')];
                        if (Array.isArray(val)) {
                            return val.flatMap(findCharArrays);
                        }
                        return [];
                    };
                    
                    // Check if this looks like a BQN error (has position info + error message)
                    const isBqnError = (val) => {
                        if (!Array.isArray(val) || val.length < 2) return false;
                        // BQN errors have structure like [posInfo, errorMsg] where errorMsg is char array
                        const strings = findCharArrays(val);
                        // If there's a string that looks like an error message, it's probably an error
                        return strings.some(s => s.includes(':') && s.length > 5);
                    };
                    
                    // Helper to format BQN output, handling character arrays as strings
                    const formatBqnOutput = (val) => {
                        if (typeof val === 'string') return val;
                        if (isCharArray(val)) return val.join('');
                        
                        // For arrays, first try fmt() then check if result needs cleanup
                        const fmtResult = fmt(val);
                        const fmtStr = String(fmtResult);
                        
                        // If fmt output has box formatting with a quoted error message, extract it
                        if (fmtStr.includes('‚îå') || fmtStr.includes('‚ïµ') || fmtStr.includes('¬∑')) {
                            const match = fmtStr.match(/"([^"]+)"/);
                            if (match && match[1].includes(':')) {
                                // It's an error message - return just the message
                                return match[1];
                            }
                        }
                        
                        return fmtStr;
                    };
                    
                    // Extract error message from BQN formatted output (box drawing)
                    const extractFromBoxFormat = (str) => {
                        // Look for quoted string in box format: "error message"
                        const match = str.match(/"([^"]+)"/);
                        if (match) return match[1];
                        return str;
                    };
                    
                    try {
                        const output = bqn(code);
                        result = { success: true, output: formatBqnOutput(output) };
                    } catch (error) {
                        // BQN errors may have message as array or pre-formatted string
                        let errMsg = error.message || String(error);
                        if (Array.isArray(error.message)) {
                            errMsg = formatBqnOutput(error.message);
                        } else if (typeof errMsg === 'string') {
                            // Check if it's box-formatted output (has ‚îå or ‚ïµ characters)
                            if (errMsg.includes('‚îå') || errMsg.includes('‚ïµ')) {
                                errMsg = extractFromBoxFormat(errMsg);
                            }
                            // Check if it looks like comma-separated chars (e.g., "0,0,‚Üï,ùï©,...")
                            else {
                                const parts = errMsg.split(',');
                                if (parts.length > 5 && parts.slice(2).every(p => p.length <= 2)) {
                                    const charStart = parts.findIndex(p => p.length === 1 && !/^\d+$/.test(p));
                                    if (charStart !== -1) {
                                        errMsg = parts.slice(charStart).join('');
                                    }
                                }
                            }
                        }
                        result = { success: false, output: errMsg };
                    }
                    const duration = Math.round(performance.now() - startTime);
                    
                    // Log to server manager (fire and forget)
                    fetch('http://localhost:8082/log', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            language: 'bqn',
                            code: code,
                            success: result.success,
                            duration: duration
                        })
                    }).catch(() => {}); // Ignore errors if server not running
                    
                    return result;
                }
            },
            uiua: {
                name: 'Uiua',
                logo: 'assets/uiua.png',
                fontClass: 'uiua',
                evaluate: async (code) => {
                    const startTime = performance.now();
                    
                    // Wait for WASM to load if not ready
                    if (!window.uiuaWasm || !window.uiuaWasm.isReady()) {
                        if (window.uiuaWasm) {
                            const loaded = await window.uiuaWasm.load();
                            if (!loaded) {
                                const error = window.uiuaWasm.getError();
                                return { 
                                    success: false, 
                                    output: `Failed to load Uiua WASM: ${error?.message || 'Unknown error'}\n\nPlease ensure the wasm/ directory contains the built WASM files.`
                                };
                            }
                        } else {
                            return { 
                                success: false, 
                                output: 'Uiua WASM module not available.\n\nRun: cd wasm/uiua && ./build.sh'
                            };
                        }
                    }
                    
                    try {
                        const result = window.uiuaWasm.eval(code);
                        const duration = Math.round(performance.now() - startTime);
                        
                        // Log to server manager (fire and forget)
                        fetch('http://localhost:8082/log', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                language: 'uiua',
                                code: code,
                                success: result.success,
                                duration: duration
                            })
                        }).catch(() => {}); // Ignore errors if server not running
                        
                        return { 
                            success: result.success, 
                            output: result.output || '',
                            formatted: result.formatted || null
                        };
                    } catch (error) {
                        return { 
                            success: false, 
                            output: `Uiua execution error: ${error.message || String(error)}`
                        };
                    }
                }
            },
            j: {
                name: 'J',
                logo: 'assets/j_logo.png',
                fontClass: 'j',
                evaluate: async (code) => {
                    try {
                        // Connect to local J server
                        const response = await fetch('http://localhost:8080/eval', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ code: code })
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Server error: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        return { 
                            success: data.success !== false, 
                            output: data.output || data.result || data.error || '' 
                        };
                    } catch (error) {
                        if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                            return { 
                                success: false, 
                                output: 'Cannot connect to local J server. Please make sure the J server is running on http://localhost:8080' 
                            };
                        }
                        return { 
                            success: false, 
                            output: error.message || String(error) 
                        };
                    }
                }
            },
            apl: {
                name: 'APL',
                logo: 'assets/apl.png',
                fontClass: 'apl',
                evaluate: async (code) => {
                    try {
                        // Connect to local APL server
                        const response = await fetch('http://localhost:8081/eval', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ code: code })
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Server error: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        return { 
                            success: data.success !== false, 
                            output: data.output || data.result || data.error || '' 
                        };
                    } catch (error) {
                        if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                            return { 
                                success: false, 
                                output: 'Cannot connect to local APL server. Please make sure the APL server is running on http://localhost:8081' 
                            };
                        }
                        return { 
                            success: false, 
                            output: error.message || String(error) 
                        };
                    }
                }
            },
            kap: {
                name: 'Kap',
                logo: 'assets/kap.png',
                fontClass: 'kap',
                evaluate: async (code) => {
                    try {
                        // Connect to local Kap server
                        const response = await fetch('http://localhost:8083/eval', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ code: code })
                        });
                        
                        if (!response.ok) {
                            throw new Error(`Server error: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        return { 
                            success: data.success !== false, 
                            output: data.output || data.result || data.error || '' 
                        };
                    } catch (error) {
                        if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                            return { 
                                success: false, 
                                output: 'Cannot connect to local Kap server. Please make sure the Kap server is running on http://localhost:8083\n\nRun: node servers/kap-server.cjs' 
                            };
                        }
                        return { 
                            success: false, 
                            output: error.message || String(error) 
                        };
                    }
                }
            },
            tinyapl: {
                name: 'TinyAPL',
                logo: 'assets/tinyapl.svg',
                fontClass: 'tinyapl',
                evaluate: async (code) => {
                    const startTime = performance.now();
                    
                    // Check if TinyAPL WASM is available
                    if (!window.tinyaplWasm || !window.tinyaplWasm.isReady()) {
                        if (window.tinyaplWasm) {
                            const loaded = await window.tinyaplWasm.load();
                            if (!loaded) {
                                const error = window.tinyaplWasm.getError();
                                return { 
                                    success: false, 
                                    output: `Failed to load TinyAPL WASM: ${error?.message || 'Unknown error'}\n\nTinyAPL WASM is not yet available. The interpreter requires a WASM build.\n\nFor now, try the online interpreter at: https://tinyapl.rubenverg.com/run/latest`
                                };
                            }
                        } else {
                            return { 
                                success: false, 
                                output: 'TinyAPL WASM module not available.\n\nTinyAPL requires a WASM build which is not yet integrated.\n\nFor now, try the online interpreter at: https://tinyapl.rubenverg.com/run/latest'
                            };
                        }
                    }
                    
                    try {
                        const result = await window.tinyaplWasm.eval(code);
                        const duration = Math.round(performance.now() - startTime);
                        
                        // Log to server manager (fire and forget)
                        fetch('http://localhost:8082/log', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                language: 'tinyapl',
                                code: code,
                                success: result.success,
                                duration: duration
                            })
                        }).catch(() => {}); // Ignore errors if server not running
                        
                        return result;
                    } catch (error) {
                        return { 
                            success: false, 
                            output: `TinyAPL execution error: ${error.message || String(error)}`
                        };
                    }
                }
            }
        };

        const languageOrder = ['apl', 'bqn', 'uiua', 'j', 'kap', 'tinyapl'];
        let currentLanguage = 'apl';
        let currentKeyboardCleanup = null;
        let lastResult = null; // Store last evaluation result for permalinks
        let lastEvaluatedCode = null; // Track what code was evaluated to detect changes

        // DOM elements
        const languageButton = document.getElementById('languageButton');
        const currentLogo = document.getElementById('currentLogo');
        const dropdown = document.getElementById('dropdown');
        const codeInput = document.getElementById('codeInput');
        const output = document.getElementById('output');
        const container = document.querySelector('.container');
        
        // Help screen
        const helpScreen = document.getElementById('helpScreen');
        
        function toggleHelpScreen() {
            helpScreen.classList.toggle('show');
        }
        
        function isHelpScreenVisible() {
            return helpScreen.classList.contains('show');
        }
        
        // Global keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ctrl+H to toggle help screen
            if (e.ctrlKey && e.key === 'h') {
                e.preventDefault();
                toggleHelpScreen();
                return;
            }
            
            // Ctrl+L to create permalink
            if (e.ctrlKey && e.key === 'l') {
                e.preventDefault();
                handleCreatePermalink();
                return;
            }
            
            // Ctrl+I to copy image to clipboard
            if (e.ctrlKey && e.key === 'i') {
                e.preventDefault();
                handleCopyImageToClipboard();
                return;
            }
            
            // Escape to close help screen if visible
            if (e.key === 'Escape' && isHelpScreenVisible()) {
                e.preventDefault();
                helpScreen.classList.remove('show');
                return;
            }
            
            // Escape to close F1 tooltip if visible (check handled by F1 tooltip code)
            // F1 global handler is set up after F1 tooltip is initialized
            
            // Don't process other shortcuts if help screen is visible
            if (isHelpScreenVisible()) {
                return;
            }
            
            // Ctrl+Up/Down to switch languages (works globally)
            if (e.ctrlKey && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
                e.preventDefault();
                const currentIndex = languageOrder.indexOf(currentLanguage);
                let newIndex;
                if (e.key === 'ArrowUp') {
                    newIndex = currentIndex > 0 ? currentIndex - 1 : languageOrder.length - 1;
                } else {
                    newIndex = currentIndex < languageOrder.length - 1 ? currentIndex + 1 : 0;
                }
                switchLanguage(languageOrder[newIndex]);
                return;
            }
            
            // Auto-focus code input when typing printable characters
            // (when not already focused and keyboard overlay is not visible)
            const keyboardWrapper = document.querySelector('.array-keyboard-wrapper.show');
            const keyboardOverlay = keyboardWrapper ? keyboardWrapper.querySelector('.keyboard-overlay') : null;
            const comboboxInputEl = document.getElementById('comboboxInput');
            
            if (document.activeElement !== codeInput && 
                document.activeElement !== comboboxInputEl &&
                !keyboardWrapper &&
                !isHelpScreenVisible() &&
                !e.ctrlKey && !e.metaKey && !e.altKey &&
                e.key.length === 1) {
                
                // For backtick (prefix key), focus and trigger a synthetic keydown
                // so the keyboard handler can activate prefix mode
                if (e.key === '`') {
                    e.preventDefault();
                    codeInput.focus();
                    // Dispatch a new keydown event to the code input
                    const syntheticEvent = new KeyboardEvent('keydown', {
                        key: '`',
                        code: 'Backquote',
                        keyCode: 192,
                        which: 192,
                        bubbles: true,
                        cancelable: true
                    });
                    codeInput.dispatchEvent(syntheticEvent);
                } else if (e.key === ' ') {
                    // Space just focuses without typing
                    e.preventDefault();
                    codeInput.focus();
                } else {
                    codeInput.focus();
                    // Let the event propagate to insert the character
                }
            }
        });

        // Language selector functionality
        languageButton.addEventListener('click', (e) => {
            e.stopPropagation();
            dropdown.classList.toggle('show');
        });

        document.addEventListener('click', (e) => {
            if (!languageButton.contains(e.target) && !dropdown.contains(e.target)) {
                dropdown.classList.remove('show');
            }
        });

        // Language selection
        document.querySelectorAll('.dropdown-item').forEach(item => {
            item.addEventListener('click', () => {
                const lang = item.dataset.lang;
                switchLanguage(lang);
                dropdown.classList.remove('show');
            });
        });

        function switchLanguage(lang) {
            const oldLang = currentLanguage;
            
            // Translate primitives in the code before switching
            if (oldLang !== lang) {
                const currentCode = getInputText();
                if (currentCode.trim()) {
                    const translatedCode = translatePrimitives(currentCode, oldLang, lang);
                    if (translatedCode !== currentCode) {
                        // Update the code input with translated code
                        codeInput.textContent = translatedCode;
                    }
                }
            }
            
            currentLanguage = lang;
            const langConfig = languages[lang];
            
            // Update logo
            currentLogo.src = langConfig.logo;
            currentLogo.alt = langConfig.name;
            
            // Update favicon to match the current language
            const favicon = document.getElementById('favicon');
            if (favicon) {
                favicon.href = langConfig.logo;
                // Update MIME type based on file extension
                favicon.type = langConfig.logo.endsWith('.svg') ? 'image/svg+xml' : 'image/png';
            }
            
            // Update input font class
            codeInput.className = `code-input ${langConfig.fontClass}`;
            
            // Update output font class
            output.className = output.className.replace(/\b(bqn|uiua|j|apl|kap|tinyapl)\b/g, '').trim();
            output.classList.add(langConfig.fontClass);
            
            // Update keyboard handler
            if (currentKeyboardCleanup) {
                currentKeyboardCleanup();
                currentKeyboardCleanup = null;
            }
            
            // BQN uses \ prefix, APL, Kap, and TinyAPL use ` prefix (each has own keymap)
            if (lang === 'bqn' || lang === 'apl' || lang === 'kap' || lang === 'tinyapl') {
                currentKeyboardCleanup = createKeyboardHandler(codeInput, lang);
            }
            
            // Update keyboard overlay for new language
            updateKeyboardForLanguage(lang);
            
            // Re-apply syntax highlighting for new language
            applySyntaxHighlighting();
            
            // Clear output
            hideOutput();
        }

        // ========================================
        // Permalink functionality (server-backed short codes)
        // ========================================
        
        // Use localhost:8084 for local dev (any local address), or same origin for production
        const isLocalDev = ['localhost', '127.0.0.1', '0.0.0.0'].includes(window.location.hostname);
        const PERMALINK_SERVER = isLocalDev ? 'http://localhost:8084' : window.location.origin;
        
        // Create a permalink via server API
        async function createPermalink() {
            const code = getInputText();
            if (!code.trim()) return null;
            
            // Only include result if the code hasn't changed since evaluation
            // This ensures the preview shows current code, with result only if it matches
            let result = null;
            let resultHtml = null;
            const codeMatchesLastEval = lastEvaluatedCode && lastEvaluatedCode === code.trim();
            if (codeMatchesLastEval && lastResult && lastResult.success) {
                if (lastResult.output) result = lastResult.output;
                if (lastResult.outputHtml) resultHtml = lastResult.outputHtml;
            }
            
            try {
                const body = { lang: currentLanguage, code: code };
                if (result) body.result = result;
                if (resultHtml) body.resultHtml = resultHtml;
                
                const response = await fetch(`${PERMALINK_SERVER}/p`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                
                const data = await response.json();
                if (data.success) {
                    // Track permalink creation for dashboard stats
                    fetch('http://localhost:8082/permalink', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: '{}'
                    }).catch(() => {});
                    return data.id;
                }
                console.warn('Failed to create permalink:', data.error);
                return null;
            } catch (e) {
                console.warn('Permalink server unavailable:', e.message);
                return null;
            }
        }
        
        // Look up a permalink code via server API
        async function lookupPermalink(shortCode) {
            if (!shortCode || shortCode.length < 4) return null;
            
            try {
                const response = await fetch(`${PERMALINK_SERVER}/p/${shortCode}`, {
                    headers: { 'Accept': 'application/json' }
                });
                const data = await response.json();
                
                if (data.success) {
                    return { lang: data.lang, code: data.code };
                }
                return null;
            } catch (e) {
                console.warn('Permalink server unavailable:', e.message);
                return null;
            }
        }
        
        // Handle Ctrl+L to generate permalink
        async function handleCreatePermalink() {
            const code = getInputText();
            if (!code.trim()) return;
            
            const shortCode = await createPermalink();
            if (shortCode) {
                // Update URL with hash (for local navigation)
                history.replaceState(null, '', '#' + shortCode);
                
                // Copy shareable URL with /p/ path (works with social media previews)
                const baseUrl = window.location.origin;
                const shareUrl = `${baseUrl}/p/${shortCode}`;
                navigator.clipboard.writeText(shareUrl).then(() => {
                    // Show brief feedback
                    showPermalinkFeedback(shortCode);
                }).catch(() => {
                    // Fallback: just show the code
                    showPermalinkFeedback(shortCode);
                });
            } else {
                showPermalinkError();
            }
        }
        
        // Handle Ctrl+I to generate and copy vertical image to clipboard
        async function handleCopyImageToClipboard() {
            const code = getInputText();
            if (!code.trim()) return;
            
            // Get current result if available
            let result = null;
            let resultHtml = null;
            const codeMatchesLastEval = lastEvaluatedCode && lastEvaluatedCode === code.trim();
            if (codeMatchesLastEval && lastResult && lastResult.success) {
                if (lastResult.output) result = lastResult.output;
                if (lastResult.outputHtml) resultHtml = lastResult.outputHtml;
            }
            
            try {
                console.log('Fetching image from:', `${PERMALINK_SERVER}/image/vertical`);
                const response = await fetch(`${PERMALINK_SERVER}/image/vertical`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        lang: currentLanguage,
                        code: code,
                        result: result,
                        resultHtml: resultHtml
                    })
                });
                
                if (!response.ok) {
                    const errText = await response.text();
                    console.error('Server error:', response.status, errText);
                    throw new Error('Server error: ' + response.status);
                }
                
                const blob = await response.blob();
                console.log('Got blob:', blob.type, blob.size);
                
                // Ensure blob is PNG type (some browsers are picky)
                const pngBlob = new Blob([blob], { type: 'image/png' });
                
                // Copy to clipboard using ClipboardItem
                try {
                    if (!navigator.clipboard || !navigator.clipboard.write) {
                        throw new Error('Clipboard API not available');
                    }
                    await navigator.clipboard.write([
                        new ClipboardItem({ 'image/png': pngBlob })
                    ]);
                    showImageCopiedFeedback();
                } catch (clipErr) {
                    console.error('Clipboard write failed:', clipErr.name, clipErr.message);
                    // Fallback: download the image
                    const url = URL.createObjectURL(pngBlob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'arraybox-code.png';
                    a.click();
                    URL.revokeObjectURL(url);
                    showFeedbackMessage('Image downloaded', '#1e40af', '#dbeafe');
                }
            } catch (e) {
                console.error('Error generating image:', e);
                showImageError();
            }
        }
        
        // Show feedback when image is copied
        function showImageCopiedFeedback() {
            showFeedbackMessage('Image copied to clipboard', '#065f46', '#d1fae5');
        }
        
        // Show error when image generation fails
        function showImageError() {
            showFeedbackMessage('Failed to generate image', '#991b1b', '#fecaca');
        }
        
        // Show error when clipboard write fails
        function showClipboardError() {
            showFeedbackMessage('Clipboard not supported (try HTTPS)', '#991b1b', '#fecaca');
        }
        
        // Generic feedback message helper
        function showFeedbackMessage(message, bgColor, textColor) {
            let feedback = document.getElementById('imageFeedback');
            if (!feedback) {
                feedback = document.createElement('div');
                feedback.id = 'imageFeedback';
                feedback.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    padding: 12px 24px;
                    border-radius: 8px;
                    font-family: 'JetBrains Mono', monospace;
                    font-size: 14px;
                    z-index: 10000;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                `;
                document.body.appendChild(feedback);
            }
            feedback.style.background = bgColor;
            feedback.style.color = textColor;
            feedback.textContent = message;
            feedback.style.opacity = '1';
            setTimeout(() => { feedback.style.opacity = '0'; }, 2000);
        }
        
        // Show error when permalink server is unavailable
        function showPermalinkError() {
            let feedback = document.getElementById('permalinkFeedback');
            if (!feedback) {
                feedback = document.createElement('div');
                feedback.id = 'permalinkFeedback';
                feedback.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #ef4444;
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    font-size: 14px;
                    font-weight: 500;
                    z-index: 10000;
                    opacity: 0;
                    transition: opacity 0.2s;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                `;
                document.body.appendChild(feedback);
            }
            
            feedback.textContent = 'Permalink server unavailable';
            feedback.style.background = '#ef4444';
            feedback.style.opacity = '1';
            
            setTimeout(() => {
                feedback.style.opacity = '0';
            }, 2000);
        }
        
        // Show brief feedback when permalink is created
        function showPermalinkFeedback(code) {
            // Create or reuse feedback element
            let feedback = document.getElementById('permalinkFeedback');
            if (!feedback) {
                feedback = document.createElement('div');
                feedback.id = 'permalinkFeedback';
                feedback.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #10b981;
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    font-size: 14px;
                    font-weight: 500;
                    z-index: 10000;
                    opacity: 0;
                    transition: opacity 0.2s;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                `;
                document.body.appendChild(feedback);
            }
            
            feedback.textContent = `Permalink copied! #${code}`;
            feedback.style.opacity = '1';
            
            setTimeout(() => {
                feedback.style.opacity = '0';
            }, 2000);
        }
        
        // Load state from URL hash or PERMALINK_CODE on page load
        async function loadFromPermalink() {
            // Check for PERMALINK_CODE (set when served from /p/:code for social media)
            // or fall back to URL hash
            const code = window.PERMALINK_CODE || window.location.hash.slice(1);
            if (!code) return false;
            
            const state = await lookupPermalink(code);
            if (!state) return false;
            
            // Switch language and set code
            switchLanguage(state.lang);
            setInputText(state.code);
            applySyntaxHighlighting();
            
            // Update URL to hash format for consistency (if we came from /p/:code)
            if (window.PERMALINK_CODE && window.location.pathname.startsWith('/p/')) {
                window.history.replaceState(null, '', `/#${code}`);
            }
            
            return true;
        }

        // Get plain text from contenteditable div (supports multiline)
        function getInputText() {
            // Use innerText to properly handle line breaks from <br> elements
            // Normalize non-breaking spaces (U+00A0) to regular spaces
            return (codeInput.innerText || '').replace(/\u00A0/g, ' ');
        }
        
        // Set cursor position in contenteditable div
        function setCursorPosition(element, pos) {
            const range = document.createRange();
            const sel = window.getSelection();
            
            let currentPos = 0;
            let targetNode = null;
            let targetOffset = 0;
            
            function traverse(node) {
                if (node.nodeType === Node.TEXT_NODE) {
                    const length = node.textContent.length;
                    if (currentPos + length >= pos) {
                        targetNode = node;
                        targetOffset = pos - currentPos;
                        return true;
                    }
                    currentPos += length;
                } else {
                    for (let child of node.childNodes) {
                        if (traverse(child)) return true;
                    }
                }
                return false;
            }
            
            traverse(element);
            
            if (targetNode) {
                range.setStart(targetNode, targetOffset);
                range.collapse(true);
                sel.removeAllRanges();
                sel.addRange(range);
            }
        }
        
        // Get current cursor position
        function getCursorPosition() {
            const sel = window.getSelection();
            if (sel.rangeCount === 0) return 0;
            
            const range = sel.getRangeAt(0);
            const preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(codeInput);
            preCaretRange.setEnd(range.endContainer, range.endOffset);
            return preCaretRange.toString().length;
        }
        
        // Debounced syntax highlighting for performance
        let highlightTimeout = null;
        let highlightAnimationFrame = null;
        
        function applySyntaxHighlighting() {
            // Clear any pending timeout
            if (highlightTimeout) {
                clearTimeout(highlightTimeout);
                highlightTimeout = null;
            }
            
            // Cancel any pending animation frame
            if (highlightAnimationFrame) {
                cancelAnimationFrame(highlightAnimationFrame);
                highlightAnimationFrame = null;
            }
            
            // Debounce: wait 50ms after last keystroke before highlighting
            highlightTimeout = setTimeout(() => {
                highlightAnimationFrame = requestAnimationFrame(() => {
                    const cursorPos = getCursorPosition();
                    const text = getInputText();
                    const highlighted = highlightCode(text, currentLanguage);
                    
                    // Only update if content actually changed
                    if (codeInput.innerHTML !== highlighted) {
                        codeInput.innerHTML = highlighted;
                        // Restore cursor position
                        setCursorPosition(codeInput, cursorPos);
                    }
                    
                    highlightAnimationFrame = null;
                });
                highlightTimeout = null;
            }, 50);
        }

        // Evaluation function
        async function evaluateCode() {
            const code = getInputText().trim();
            if (!code) {
                hideOutput();
                lastResult = null;
                return;
            }

            const langConfig = languages[currentLanguage];
            const result = await langConfig.evaluate(code);
            
            // Store result for permalinks (use plain text output)
            lastResult = result;
            lastEvaluatedCode = code; // Track what code produced this result
            
            // If formatted code is returned (Uiua), replace input with it
            if (result.formatted && result.formatted.trim() !== code) {
                setInputText(result.formatted.trim());
            }
            
            // Use HTML rendering if available (TinyAPL fancy arrays), otherwise plain text
            if (result.outputHtml) {
                output.innerHTML = result.outputHtml;
            } else {
                output.textContent = result.output;
            }
            output.className = `output show ${langConfig.fontClass} ${result.success ? '' : 'error'}`;
            
            // Dynamically adjust font size to fit content, then center
            requestAnimationFrame(() => {
                // Reset to default font size (scaled 1.75x)
                let fontSize = 42;
                const minFontSize = 18;
                output.style.fontSize = `${fontSize}px`;
                
                // Reduce font size until content fits or we hit minimum
                while (output.scrollWidth > output.clientWidth && fontSize > minFontSize) {
                    fontSize -= 1;
                    output.style.fontSize = `${fontSize}px`;
                }
                
                // Move container up by half the output height to keep input+output centered
                const outputHeight = output.offsetHeight;
                const margin = 24; // margin-top of output (scaled 1.75x)
                container.style.transform = `translateY(-${(outputHeight + margin) / 2}px)`;
            });
        }
        
        // Get cursor position as character offset from start
        function getCursorOffset() {
            const sel = window.getSelection();
            if (sel.rangeCount === 0) return 0;
            
            const range = sel.getRangeAt(0);
            const preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(codeInput);
            preCaretRange.setEnd(range.startContainer, range.startOffset);
            return preCaretRange.toString().length;
        }
        
        // Set cursor position by character offset
        function setCursorOffset(offset) {
            const sel = window.getSelection();
            const range = document.createRange();
            
            // Walk through text nodes to find the right position
            let currentOffset = 0;
            const walker = document.createTreeWalker(codeInput, NodeFilter.SHOW_TEXT, null, false);
            let node;
            
            while ((node = walker.nextNode())) {
                const nodeLength = node.textContent.length;
                if (currentOffset + nodeLength >= offset) {
                    range.setStart(node, offset - currentOffset);
                    range.collapse(true);
                    sel.removeAllRanges();
                    sel.addRange(range);
                    return;
                }
                currentOffset += nodeLength;
            }
            
            // If offset is beyond content, place at end
            if (codeInput.lastChild) {
                range.selectNodeContents(codeInput);
                range.collapse(false);
                sel.removeAllRanges();
                sel.addRange(range);
            }
        }
        
        // Set the input text and apply syntax highlighting, preserving cursor position
        function setInputText(text) {
            const cursorOffset = getCursorOffset();
            codeInput.textContent = text;
            applySyntaxHighlighting();
            // Restore cursor after a microtask to ensure DOM is updated
            queueMicrotask(() => {
                setCursorOffset(Math.min(cursorOffset, text.length));
            });
        }

        function hideOutput() {
            output.classList.remove('show');
            container.style.transform = '';
            lastResult = null;
            lastEvaluatedCode = null;
        }

        // Initialize editor features (alignment, auto-expand)
        const editorFeatures = createEditorFeaturesManager(
            { container, inputContainer: document.querySelector('.input-container'), codeInput, output },
            () => currentLanguage,
            getInputText,
            setInputText,
            applySyntaxHighlighting
        );
        editorFeatures.init();
        
        // Keyboard shortcuts for code input
        codeInput.addEventListener('keydown', (e) => {
            // Shift+Enter to insert newline
            if (e.key === 'Enter' && e.shiftKey) {
                // Let the browser handle the newline insertion
                return;
            }
            // Enter to evaluate (auto-align first)
            if (e.key === 'Enter') {
                e.preventDefault();
                editorFeatures.alignAll();
                evaluateCode();
            }
        });

        // Handle input changes - apply syntax highlighting (output persists until next eval)
        codeInput.addEventListener('input', () => {
            // Debounced highlighting will be applied automatically
            applySyntaxHighlighting();
        }, { passive: true });
        
        // Handle paste - ensure plain text only
        codeInput.addEventListener('paste', (e) => {
            e.preventDefault();
            const text = e.clipboardData.getData('text/plain');
            
            // Insert text at cursor
            const sel = window.getSelection();
            if (sel.rangeCount > 0) {
                const range = sel.getRangeAt(0);
                range.deleteContents();
                const textNode = document.createTextNode(text);
                range.insertNode(textNode);
                
                // Move cursor after pasted text
                range.setStartAfter(textNode);
                range.setEndAfter(textNode);
                sel.removeAllRanges();
                sel.addRange(range);
                
                // Trigger input event to apply highlighting
                codeInput.dispatchEvent(new Event('input', { bubbles: true }));
            }
        });

        // Initialize keyboard handler for default language (APL)
        currentKeyboardCleanup = createKeyboardHandler(codeInput, 'apl');
        
        // Initialize visual keyboard for default language (APL)
        const aplConfig = keyboardConfigs.apl;
        visualKeyboard = new ArrayKeyboard({
            keymap: aplConfig.keymap,
            language: aplConfig.language,
            prefixKey: aplConfig.prefixKey,
            fontFamily: aplConfig.fontFamily,
            syntaxRules: aplConfig.syntaxRules,
            glyphNames: aplConfig.glyphNames,
            glyphDocs: aplConfig.glyphDocs,
            docLinks: aplConfig.docLinks,
            logoPath: aplConfig.logoPath
        });
        
        // Load state from URL permalink (if present)
        loadFromPermalink().then((loaded) => {
            // Apply initial syntax highlighting after loading
            applySyntaxHighlighting();
            // If content was loaded, adjust container width for it
            if (loaded) {
                editorFeatures.handleAutoExpand();
            }
        });
        
        // Track visitor (for dashboard stats)
        (function trackVisitor() {
            let sessionId = localStorage.getItem('arraybox_session');
            if (!sessionId) {
                sessionId = Math.random().toString(36).substring(2) + Date.now().toString(36);
                localStorage.setItem('arraybox_session', sessionId);
            }
            fetch('http://localhost:8082/visitor', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ sessionId })
            }).catch(() => {}); // Ignore if server not running
        })();
        
        // Show keyboard hint for 10 seconds
        const keyboardHint = document.getElementById('keyboardHint');
        setTimeout(() => {
            keyboardHint.classList.add('hidden');
            // Remove from DOM after fade out completes
            setTimeout(() => {
                keyboardHint.remove();
            }, 500);
        }, 10000);

        // ========================================
        // Ctrl+Space Primitive Combo Box
        // ========================================
        
        const primitiveCombobox = document.getElementById('primitiveCombobox');
        const comboboxInput = document.getElementById('comboboxInput');
        const comboboxList = document.getElementById('comboboxList');
        let comboboxSelectedIndex = 0;
        let filteredPrimitives = [];
        let savedCursorPosition = null;
        
        // Build reverse keymap (glyph -> shortcut) for each language
        function buildReverseKeymap(keymap, prefixKey, language) {
            const reverse = {};
            
            if (!keymap || Object.keys(keymap).length === 0) {
                return reverse;
            }
            
            if (language === 'tinyapl') {
                // TinyAPL uses special structure with symP, symPS, symPP, symPPS
                for (const [code, entry] of Object.entries(keymap)) {
                    // Extract the key letter from code (e.g., 'KeyA' -> 'a')
                    let key = '';
                    if (code.startsWith('Key')) {
                        key = code.slice(3).toLowerCase();
                    } else if (code.startsWith('Digit')) {
                        key = code.slice(5);
                    } else if (code === 'Backquote') {
                        key = '`';
                    } else if (code === 'Minus') {
                        key = '-';
                    } else if (code === 'Equal') {
                        key = '=';
                    } else if (code === 'BracketLeft') {
                        key = '[';
                    } else if (code === 'BracketRight') {
                        key = ']';
                    } else if (code === 'Backslash') {
                        key = '\\';
                    } else if (code === 'Semicolon') {
                        key = ';';
                    } else if (code === 'Quote') {
                        key = "'";
                    } else if (code === 'Comma') {
                        key = ',';
                    } else if (code === 'Period') {
                        key = '.';
                    } else if (code === 'Slash') {
                        key = '/';
                    } else if (code === 'Space') {
                        key = 'space';
                    }
                    
                    if (entry.symP && !reverse[entry.symP]) {
                        reverse[entry.symP] = `${prefixKey} ${key}`;
                    }
                    if (entry.symPS && !reverse[entry.symPS]) {
                        reverse[entry.symPS] = `${prefixKey} shift+${key}`;
                    }
                    if (entry.symPP && !reverse[entry.symPP]) {
                        reverse[entry.symPP] = `${prefixKey}${prefixKey} ${key}`;
                    }
                    if (entry.symPPS && !reverse[entry.symPPS]) {
                        reverse[entry.symPPS] = `${prefixKey}${prefixKey} shift+${key}`;
                    }
                }
            } else {
                // Standard keymap format
                for (const [key, glyph] of Object.entries(keymap)) {
                    if (glyph && !reverse[glyph]) {
                        const isShifted = key === key.toUpperCase() && key.toLowerCase() !== key;
                        const displayKey = isShifted ? `shift+${key.toLowerCase()}` : key;
                        reverse[glyph] = `${prefixKey} ${displayKey}`;
                    }
                }
            }
            return reverse;
        }
        
        // Get input hint for languages without keymaps (Uiua, J)
        function getInputHint(glyph, name, language) {
            if (language === 'uiua') {
                // For Uiua, you can type the name and it auto-completes
                const nameParts = name.split(' ');
                const firstName = nameParts[0].toLowerCase();
                return `type: ${firstName}`;
            } else if (language === 'j') {
                // For J, just type the glyph directly
                return 'type directly';
            }
            return '';
        }
        
        // Get syntax class for a glyph based on current language's syntax rules
        function getSyntaxClassForGlyph(glyph) {
            const config = keyboardConfigs[currentLanguage];
            if (!config || !config.syntaxRules) return '';
            
            const rules = config.syntaxRules;
            
            // Handle compound inverse glyphs for Uiua (¬∞X and ‚åùX patterns)
            if (currentLanguage === 'uiua' && glyph.length > 1) {
                const firstChar = glyph[0];
                if (firstChar === '¬∞' || firstChar === '‚åù') {
                    return 'syntax-uiua-modifier-monadic';  // 1-modifiers for Uiua
                }
            }
            
            // Shared classifications
            if (rules.comments && rules.comments.includes(glyph)) {
                return 'syntax-comment';
            }
            if (rules.constants && rules.constants.includes(glyph)) {
                return 'syntax-number';
            }
            
            // Language-specific classifications
            if (currentLanguage === 'uiua') {
                // Uiua: monadic/dyadic functions AND monadic/dyadic modifiers
                if (rules.monadic && rules.monadic.includes(glyph)) {
                    return 'syntax-uiua-function-monadic';
                }
                if (rules.functions && rules.functions.includes(glyph)) {
                    return 'syntax-uiua-function-dyadic';
                }
                if (rules.dyadic && rules.dyadic.includes(glyph)) {
                    return 'syntax-uiua-modifier-monadic';
                }
                if (rules.modifier && rules.modifier.includes(glyph)) {
                    return 'syntax-uiua-modifier-dyadic';
                }
            } else {
                // Other languages: functions + monadic/dyadic modifiers
                if (rules.functions && rules.functions.includes(glyph)) {
                    return 'syntax-function';
                }
                if (rules.monadic && rules.monadic.includes(glyph)) {
                    return 'syntax-modifier-monadic';
                }
                if (rules.dyadic && rules.dyadic.includes(glyph)) {
                    return 'syntax-modifier-dyadic';
                }
            }
            
            return '';
        }
        
        // Build list of primitives for current language
        function buildPrimitivesList() {
            const config = keyboardConfigs[currentLanguage];
            if (!config || !config.glyphNames) return [];
            
            const glyphNames = config.glyphNames;
            const keymap = config.keymap || {};
            const prefixKey = config.prefixKey || '`';
            const reverseKeymap = buildReverseKeymap(keymap, prefixKey, currentLanguage);
            
            const primitives = [];
            for (const [glyph, name] of Object.entries(glyphNames)) {
                // Get shortcut from keymap, or input hint for languages without keymaps
                let shortcut = reverseKeymap[glyph];
                if (!shortcut && (currentLanguage === 'uiua' || currentLanguage === 'j')) {
                    shortcut = getInputHint(glyph, name, currentLanguage);
                }
                
                primitives.push({
                    glyph,
                    name,
                    shortcut: shortcut || ''
                });
            }
            
            // Sort by name alphabetically
            primitives.sort((a, b) => a.name.localeCompare(b.name));
            return primitives;
        }
        
        // Fuzzy match function - returns match score and highlighted name
        function fuzzyMatch(text, query) {
            if (!query) return { score: 1, highlighted: text };
            
            const textLower = text.toLowerCase();
            const queryLower = query.toLowerCase();
            
            // Check for exact substring match first (highest priority)
            const substringIndex = textLower.indexOf(queryLower);
            if (substringIndex !== -1) {
                const before = text.slice(0, substringIndex);
                const match = text.slice(substringIndex, substringIndex + query.length);
                const after = text.slice(substringIndex + query.length);
                return {
                    score: 100 + (substringIndex === 0 ? 50 : 0) + (query.length / text.length * 20),
                    highlighted: `${before}<em>${match}</em>${after}`
                };
            }
            
            // Fuzzy matching - find all query chars in order
            let textIdx = 0;
            let queryIdx = 0;
            let score = 0;
            let highlighted = '';
            let lastMatchIdx = -1;
            let consecutiveMatches = 0;
            
            while (textIdx < text.length && queryIdx < queryLower.length) {
                if (textLower[textIdx] === queryLower[queryIdx]) {
                    highlighted += `<em>${text[textIdx]}</em>`;
                    score += 10;
                    
                    // Bonus for consecutive matches
                    if (lastMatchIdx === textIdx - 1) {
                        consecutiveMatches++;
                        score += consecutiveMatches * 5;
                    } else {
                        consecutiveMatches = 0;
                    }
                    
                    // Bonus for matching at word boundaries
                    if (textIdx === 0 || text[textIdx - 1] === ' ' || text[textIdx - 1] === '/') {
                        score += 15;
                    }
                    
                    lastMatchIdx = textIdx;
                    queryIdx++;
                } else {
                    highlighted += text[textIdx];
                }
                textIdx++;
            }
            
            // Add remaining text
            highlighted += text.slice(textIdx);
            
            // Return null if not all query chars were found
            if (queryIdx < queryLower.length) {
                return null;
            }
            
            return { score, highlighted };
        }
        
        // Filter and render primitives list
        function filterPrimitives(query) {
            const allPrimitives = buildPrimitivesList();
            
            if (!query) {
                filteredPrimitives = allPrimitives.map(p => ({ ...p, highlighted: p.name }));
            } else {
                filteredPrimitives = [];
                for (const p of allPrimitives) {
                    // Match against name
                    const nameMatch = fuzzyMatch(p.name, query);
                    // Also check if query matches the glyph itself
                    const glyphMatch = p.glyph.includes(query) ? { score: 200, highlighted: p.name } : null;
                    
                    const bestMatch = glyphMatch || nameMatch;
                    if (bestMatch) {
                        filteredPrimitives.push({
                            ...p,
                            score: bestMatch.score,
                            highlighted: bestMatch.highlighted
                        });
                    }
                }
                // Sort by score descending
                filteredPrimitives.sort((a, b) => b.score - a.score);
            }
            
            renderComboboxList();
        }
        
        // Render the combo box list
        function renderComboboxList() {
            comboboxList.innerHTML = '';
            
            if (filteredPrimitives.length === 0) {
                comboboxList.innerHTML = '<div class="primitive-combobox-empty">No primitives found</div>';
                return;
            }
            
            const fontClass = languages[currentLanguage]?.fontClass || '';
            
            filteredPrimitives.forEach((p, index) => {
                const item = document.createElement('div');
                item.className = 'primitive-combobox-item' + (index === comboboxSelectedIndex ? ' selected' : '');
                item.dataset.index = index;
                
                const glyphSpan = document.createElement('span');
                const syntaxClass = getSyntaxClassForGlyph(p.glyph);
                glyphSpan.className = 'primitive-combobox-glyph ' + fontClass + (syntaxClass ? ' ' + syntaxClass : '');
                glyphSpan.textContent = p.glyph;
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'primitive-combobox-name';
                nameSpan.innerHTML = p.highlighted;
                
                const shortcutSpan = document.createElement('span');
                shortcutSpan.className = 'primitive-combobox-shortcut';
                if (p.shortcut) {
                    // Format shortcut nicely: split by space and wrap each part
                    const parts = p.shortcut.split(' ');
                    shortcutSpan.innerHTML = parts.map(part => `<kbd>${part}</kbd>`).join(' ');
                }
                
                item.appendChild(glyphSpan);
                item.appendChild(nameSpan);
                item.appendChild(shortcutSpan);
                
                item.addEventListener('click', () => {
                    selectPrimitive(index);
                });
                
                item.addEventListener('mouseenter', () => {
                    comboboxSelectedIndex = index;
                    updateComboboxSelection();
                });
                
                comboboxList.appendChild(item);
            });
            
            // Scroll selected item into view
            scrollSelectedIntoView();
        }
        
        // Update selection highlighting
        function updateComboboxSelection() {
            const items = comboboxList.querySelectorAll('.primitive-combobox-item');
            items.forEach((item, index) => {
                item.classList.toggle('selected', index === comboboxSelectedIndex);
            });
            scrollSelectedIntoView();
        }
        
        // Scroll selected item into view
        function scrollSelectedIntoView() {
            const selected = comboboxList.querySelector('.primitive-combobox-item.selected');
            if (selected) {
                selected.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
            }
        }
        
        // Select a primitive and insert it
        function selectPrimitive(index) {
            if (index < 0 || index >= filteredPrimitives.length) return;
            
            const primitive = filteredPrimitives[index];
            const cursorPos = savedCursorPosition;
            
            // Hide combo box first
            primitiveCombobox.classList.remove('show');
            comboboxInput.value = '';
            filteredPrimitives = [];
            
            // Restore proper vertical centering based on output visibility
            restoreVerticalCentering();
            
            // Focus code input and restore cursor position
            codeInput.focus();
            if (cursorPos !== null) {
                setCursorPosition(codeInput, cursorPos);
            }
            
            // Now insert the glyph at the restored cursor position
            insertText(codeInput, primitive.glyph);
            applySyntaxHighlighting();
        }
        
        // Show the combo box
        function showCombobox() {
            // Save cursor position
            savedCursorPosition = getCursorPosition();
            
            // Position the combo box below the code input
            // Since the combo box is inside input-container (position: relative),
            // we position it relative to that container
            const inputRect = codeInput.getBoundingClientRect();
            const containerRect = codeInput.parentElement.getBoundingClientRect();
            
            // Position below the code input, aligned to left edge
            // Use same margin as output (24px)
            primitiveCombobox.style.top = `${inputRect.height + 24}px`;
            primitiveCombobox.style.left = '0';
            primitiveCombobox.style.width = `${inputRect.width}px`;
            primitiveCombobox.style.maxWidth = `${inputRect.width}px`;
            
            primitiveCombobox.classList.add('show');
            comboboxInput.value = '';
            comboboxSelectedIndex = 0;
            filterPrimitives('');
            comboboxInput.focus();
            
            // Center the code editor + combo box vertically (like output does)
            requestAnimationFrame(() => {
                const comboboxHeight = primitiveCombobox.offsetHeight;
                const margin = 24; // Same margin as output
                container.style.transform = `translateY(-${(comboboxHeight + margin) / 2}px)`;
            });
        }
        
        // Hide the combo box
        function hideCombobox() {
            primitiveCombobox.classList.remove('show');
            comboboxInput.value = '';
            filteredPrimitives = [];
            
            // Restore vertical centering - if output is visible, center for output
            restoreVerticalCentering();
            
            // Restore focus to code input
            codeInput.focus();
        }
        
        // Restore proper vertical centering based on whether output is visible
        function restoreVerticalCentering() {
            if (output.classList.contains('show')) {
                // Output is visible - center input+output
                requestAnimationFrame(() => {
                    const outputHeight = output.offsetHeight;
                    const margin = 24; // margin-top of output (scaled 1.75x)
                    container.style.transform = `translateY(-${(outputHeight + margin) / 2}px)`;
                });
            } else {
                // No output - reset transform
                container.style.transform = '';
            }
        }
        
        // Check if combo box is visible
        function isComboboxVisible() {
            return primitiveCombobox.classList.contains('show');
        }
        
        // Handle combo box input
        comboboxInput.addEventListener('input', () => {
            comboboxSelectedIndex = 0;
            filterPrimitives(comboboxInput.value);
        });
        
        // Handle combo box keyboard navigation
        comboboxInput.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                comboboxSelectedIndex = Math.min(comboboxSelectedIndex + 1, filteredPrimitives.length - 1);
                updateComboboxSelection();
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                comboboxSelectedIndex = Math.max(comboboxSelectedIndex - 1, 0);
                updateComboboxSelection();
            } else if (e.key === 'Enter') {
                e.preventDefault();
                selectPrimitive(comboboxSelectedIndex);
            } else if (e.key === 'Escape') {
                e.preventDefault();
                hideCombobox();
            } else if (e.key === 'Tab') {
                e.preventDefault();
                selectPrimitive(comboboxSelectedIndex);
            }
        });
        
        // Add Ctrl+Space handler to code input
        codeInput.addEventListener('keydown', (e) => {
            // Ctrl+Space to show combo box
            if (e.ctrlKey && e.key === ' ') {
                e.preventDefault();
                e.stopPropagation();
                
                // Don't show if keyboard overlay is visible
                if (visualKeyboard && visualKeyboard.isVisible()) {
                    return;
                }
                
                if (isComboboxVisible()) {
                    hideCombobox();
                } else {
                    showCombobox();
                }
            }
        });
        
        // Close combo box when clicking outside
        document.addEventListener('click', (e) => {
            if (isComboboxVisible() && 
                !primitiveCombobox.contains(e.target) && 
                e.target !== codeInput) {
                hideCombobox();
            }
        });
        
        // Prevent combo box clicks from propagating
        primitiveCombobox.addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        // Keep focus in combo box input when clicking inside the combo box
        primitiveCombobox.addEventListener('mousedown', (e) => {
            // If clicking on an item, let the click handler work
            if (e.target.closest('.primitive-combobox-item')) {
                return;
            }
            // Otherwise prevent default to keep focus in input
            if (e.target !== comboboxInput) {
                e.preventDefault();
            }
        });

        // ========================================
        // F1 Documentation Tooltip
        // ========================================
        
        const f1DocTooltip = document.getElementById('f1DocTooltip');
        let f1TooltipVisible = false;
        
        /**
         * Get all known glyphs for the current language
         * Includes functions, monadic, dyadic, modifiers, constants from syntax rules
         * and multi-char tokens for J
         */
        function getAllGlyphs(language) {
            const rules = syntaxRules[language];
            if (!rules) return new Set();
            
            const glyphs = new Set();
            
            // Add all single-char glyphs
            if (rules.functions) rules.functions.forEach(g => glyphs.add(g));
            if (rules.monadic) rules.monadic.forEach(g => glyphs.add(g));
            if (rules.dyadic) rules.dyadic.forEach(g => glyphs.add(g));
            if (rules.modifier) rules.modifier.forEach(g => glyphs.add(g));
            if (rules.constants) rules.constants.forEach(g => glyphs.add(g));
            if (rules.comparison) rules.comparison.forEach(g => glyphs.add(g));
            
            // For J, also add multi-char tokens
            if (language === 'j' && rules.multiChar) {
                if (rules.multiChar.functions) rules.multiChar.functions.forEach(g => glyphs.add(g));
                if (rules.multiChar.monadic) rules.multiChar.monadic.forEach(g => glyphs.add(g));
                if (rules.multiChar.dyadic) rules.multiChar.dyadic.forEach(g => glyphs.add(g));
            }
            
            return glyphs;
        }
        
        /**
         * Find the glyph at or before the cursor position
         * Returns { glyph, position } or null if no glyph found
         */
        function findGlyphAtCursor() {
            const text = getInputText();
            const cursorPos = getCursorPosition();
            
            if (!text) return null;
            
            const allGlyphs = getAllGlyphs(currentLanguage);
            const glyphDocs = glyphDocsByLanguage[currentLanguage] || {};
            
            // For J language, try to match multi-char tokens first (looking at chars before cursor)
            if (currentLanguage === 'j') {
                // Try 3-char, then 2-char matches
                for (const len of [3, 2]) {
                    if (cursorPos >= len) {
                        const substr = text.substring(cursorPos - len, cursorPos);
                        if (allGlyphs.has(substr) && glyphDocs[substr]) {
                            return { glyph: substr, position: cursorPos - len };
                        }
                    }
                }
            }
            
            // Try single character at cursor position (if cursor is on a glyph)
            if (cursorPos < text.length) {
                const charAtCursor = text[cursorPos];
                if (allGlyphs.has(charAtCursor) && glyphDocs[charAtCursor]) {
                    return { glyph: charAtCursor, position: cursorPos };
                }
            }
            
            // Try character before cursor
            if (cursorPos > 0) {
                const charBefore = text[cursorPos - 1];
                if (allGlyphs.has(charBefore) && glyphDocs[charBefore]) {
                    return { glyph: charBefore, position: cursorPos - 1 };
                }
            }
            
            return null;
        }
        
        /**
         * Build tooltip HTML content for a glyph
         */
        function buildF1TooltipContent(glyph, doc) {
            // Use font family from keyboard config
            const kbConfig = keyboardConfigs[currentLanguage];
            const fontFamily = kbConfig?.fontFamily || "'Courier New', monospace";
            
            // Get syntax class for glyph coloring
            const syntaxClass = getSyntaxClass(glyph, currentLanguage);
            
            let html = '<div class="f1-doc-tooltip-header">';
            html += `<span class="f1-doc-tooltip-glyph ${syntaxClass}" style="font-family: ${fontFamily}">${escapeHtml(glyph)}</span>`;
            html += `<span class="f1-doc-tooltip-type">${escapeHtml(doc.type || 'primitive')}</span>`;
            if (doc.signature) {
                html += `<span class="f1-doc-tooltip-sig">${escapeHtml(doc.signature)}</span>`;
            }
            html += '</div>';
            
            // Handle different doc formats
            if (doc.overloads && doc.overloads.length > 0) {
                // TinyAPL style: multiple overloads
                for (const overload of doc.overloads) {
                    html += '<div class="f1-doc-tooltip-section">';
                    html += `<div class="f1-doc-tooltip-section-title">${escapeHtml(overload.name)}</div>`;
                    if (overload.description) {
                        html += `<div class="f1-doc-tooltip-section-desc">${escapeHtml(overload.description)}</div>`;
                    }
                    if (overload.example) {
                        html += `<div class="f1-doc-tooltip-example" style="font-family: ${fontFamily}">${escapeHtml(overload.example)}</div>`;
                    }
                    html += '</div>';
                }
            } else if (doc.monad || doc.dyad) {
                // BQN/APL/J style: monad and dyad sections
                if (doc.monad) {
                    html += '<div class="f1-doc-tooltip-section">';
                    html += `<div class="f1-doc-tooltip-section-title">${escapeHtml(doc.monad.name)}</div>`;
                    if (doc.monad.description) {
                        html += `<div class="f1-doc-tooltip-section-desc">${escapeHtml(doc.monad.description)}</div>`;
                    }
                    if (doc.monad.example) {
                        html += `<div class="f1-doc-tooltip-example" style="font-family: ${fontFamily}">${escapeHtml(doc.monad.example)}</div>`;
                    }
                    html += '</div>';
                }
                if (doc.dyad) {
                    html += '<div class="f1-doc-tooltip-section">';
                    html += `<div class="f1-doc-tooltip-section-title">${escapeHtml(doc.dyad.name)}</div>`;
                    if (doc.dyad.description) {
                        html += `<div class="f1-doc-tooltip-section-desc">${escapeHtml(doc.dyad.description)}</div>`;
                    }
                    if (doc.dyad.example) {
                        html += `<div class="f1-doc-tooltip-example" style="font-family: ${fontFamily}">${escapeHtml(doc.dyad.example)}</div>`;
                    }
                    html += '</div>';
                }
            } else {
                // Uiua style: simple name and description
                if (doc.name) {
                    html += `<div class="f1-doc-tooltip-title-line">${escapeHtml(doc.name)}</div>`;
                }
                if (doc.description) {
                    const shortDesc = doc.description.length > 300 ? 
                        doc.description.substring(0, 297) + '...' : doc.description;
                    html += `<div class="f1-doc-tooltip-desc">${escapeHtml(shortDesc)}</div>`;
                }
                if (doc.example) {
                    html += `<div class="f1-doc-tooltip-example" style="font-family: ${fontFamily}">${escapeHtml(doc.example)}</div>`;
                }
            }
            
            // Doc link
            if (doc.docUrl) {
                html += `<a class="f1-doc-tooltip-link" href="${doc.docUrl}" target="_blank" rel="noopener">View full docs ‚Üó</a>`;
            }
            
            // Hint
            html += '<div class="f1-doc-tooltip-hint">Press F1 or Escape to close</div>';
            
            return html;
        }
        
        /**
         * Show F1 documentation tooltip for a glyph
         * Positions tooltip to right of container, slides container left
         */
        function showF1Tooltip(glyph, doc) {
            f1DocTooltip.innerHTML = buildF1TooltipContent(glyph, doc);
            
            // Position tooltip to the right of where container will be
            const containerRect = container.getBoundingClientRect();
            const tooltipWidth = 560;
            const gap = 28;
            
            // Calculate position: container center + half container width + gap
            // After container shifts left by 300px, tooltip should be to its right
            const containerCenterX = containerRect.left + containerRect.width / 2;
            const newContainerRight = containerCenterX - 300 + containerRect.width / 2;
            const tooltipLeft = newContainerRight + gap;
            
            f1DocTooltip.style.left = `${tooltipLeft}px`;
            
            // Add class to body to trigger container shift
            document.body.classList.add('f1-doc-active');
            f1DocTooltip.classList.add('show');
            f1TooltipVisible = true;
        }
        
        /**
         * Hide F1 documentation tooltip
         */
        function hideF1Tooltip() {
            document.body.classList.remove('f1-doc-active');
            f1DocTooltip.classList.remove('show');
            f1TooltipVisible = false;
        }
        
        /**
         * Check if F1 tooltip is visible
         */
        function isF1TooltipVisible() {
            return f1TooltipVisible;
        }
        
        // F1 key handler for code input
        codeInput.addEventListener('keydown', (e) => {
            if (e.key === 'F1') {
                e.preventDefault();
                
                // If tooltip is visible, hide it
                if (isF1TooltipVisible()) {
                    hideF1Tooltip();
                    return;
                }
                
                // Don't show if other overlays are visible
                if (visualKeyboard && visualKeyboard.isVisible()) return;
                if (isComboboxVisible()) return;
                if (isHelpScreenVisible()) return;
                
                // Find glyph at cursor
                const found = findGlyphAtCursor();
                if (!found) return;
                
                // Get documentation for the glyph
                const glyphDocs = glyphDocsByLanguage[currentLanguage];
                if (!glyphDocs) return;
                
                const doc = glyphDocs[found.glyph];
                if (!doc) return;
                
                showF1Tooltip(found.glyph, doc);
            }
            
            // Escape to close tooltip
            if (e.key === 'Escape' && isF1TooltipVisible()) {
                e.preventDefault();
                hideF1Tooltip();
            }
        });
        
        // Close F1 tooltip when clicking outside
        document.addEventListener('click', (e) => {
            if (isF1TooltipVisible() && !f1DocTooltip.contains(e.target)) {
                hideF1Tooltip();
            }
        });
        
        // Close F1 tooltip when typing
        codeInput.addEventListener('input', () => {
            if (isF1TooltipVisible()) {
                hideF1Tooltip();
            }
        });
        
        // Global Escape handler for F1 tooltip (handles escape when focus is elsewhere)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && isF1TooltipVisible()) {
                e.preventDefault();
                hideF1Tooltip();
            }
        });
    </script>
</body>
</html>
