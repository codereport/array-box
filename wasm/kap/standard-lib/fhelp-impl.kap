namespace("man")

m ← map:with "" "
  man: info about Kap functions

  try the following: 

  ]man primitives - see the list of primitives
  ]man <primitive> - help about each primitive, eg. ]man ⟦
  ]man namespaces - general info about namespaces
  ]man <namespace> - more info about each namespace and their functions
  ]man <namespace>:<function> - more info about a particular function
  ]man search <string> - search through help articles for a string


  Please note that Kap is being actively developed. Not all functions that are listed in the GUI function list
  are represented here. Old functions are deprecated and new ones are added. Function naming conventions might 
  vary. Some functions are named after their designated name in the GUI, some per the reference documentation,
  and yet others after the corresponding APL function. 

  If you ever feel like this inline documentation is out of date, 
  create an issue at   https://codeberg.org/loke/array/issues
  or come say hi to matrix:   https://matrix.to/#/#kap:dhsdevelopments.com
"
m ← m map:with "namespaces" "

  All Kap symbols and functions reside in a namespace. A namespace is a grouping of symbols. If you don't 
  specify any particular namespace, a new function will be assigned to default namespace. If a keyword's 
  namespace is blank, its default namespace will be keyword.


  declare   Declare symbol parameters
  import   Load symbols into current namespace
  namespace   Change current namespace
  use   Load source file

  
  Help articles exist for the following namespaces:
  
  audio chart crypto ffi forms gui http httpserver io io2 json jvm math mod msoffice net o3 objects regex sql time unicode valkey

"
m ← m map:with "use" "
  use(filepath)

  Load source file. When the parser sees a use statement, the file is looked up and loaded as a separate 
  parse unit. Any changes to the default namespace made while processing the file will be reverted once 
  parsing of the file is complete. The use statement will expect parentheses. filepath is a string containing 
  file name (from the working directory) or a full path + file name.


  use(\"myscript.kap\")
⍬
  use(\"/full/path/to/kap/array/standard-lib/fhelp.kap\")
⍬
"
m ← m map:with "namespace" "
  namespace(string)

  Change current namespace. Set namespace as the default namespace for this parse unit.
  The namespace statement expects parentheses. 


  namespace(\"kap\")
null
  namespace(\"myown\")
null
"
m ← m map:with "import" "
  import(string)

  Makes all exported symbols from namespace visible in the current namespace without the need to specify 
  namespace explicitly.


  import(\"math\")
null
  sin pi÷2
1.0
"
m ← m map:with "declare" "
  declare(symbol value)

  Set symbol parameters. First argument is a symbol, the second is parameter value.


  declare(:export sym)   Declares one or more symbols as exported. sym is either a single symbol or a space-separated 
  list of symbols within parentheses, for example: (foo bar). Symbols that are declared as exported will be accessible 
  from the local namespace after performing an import.

  declare(:const sym)   Declare constant. This statement indicates that sym should not be modifiable. An attempt 
  to modify such values will raise an error.

  declare(:singleCharExported \"S\")   Parse symbol as single character. The value argument must be a single character.
  Tells the tokeniser that the given character should not form part of a word, but always be parsed as a single symbol. 
  This allows single-symbol names to be written without needing to be delimited with spaces.
"
m ← m map:with "⎕a" "
  ⎕a

  Lowercase ASCII letters. This variable contains the following string: \"abcdefghijklmnopqrstuvwxyz\"

"
m ← m map:with "⎕A" "
  ⎕A

  Uppercase ASCII letters. This variable contains the following string: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"

"
m ← m map:with "⎕d" "
  ⎕d

  Standard decimal digits. This variable contains the following string: \"0123456789\"

"
m ← m map:with "⎕argv" "
  ⎕argv
 
  Argument list. This variable contains an array of strings representing the arguments given to the 
  interpreter when it was started.

"
m ← m map:with "primitives" "
  Kap Card

        Functions                                       Operators
        Monadic          Dyadic                      
                                                     /  Reduce                      
     +  Conjugate        Addition                    ⌿  Reduce First              
     -  Negation         Subtraction                 \  Scan                                                                                                    
     ×  Direction        Multiply                    ⍀  Expand First / Scan First 
     ÷  Reciprocal       Divide                      ¨  Each                      
     |  Magnitude        Modulo                      ⍨  Duplicate / Commute       
     ⌈  Ceiling          Maximum                     ⍣  Repeat/Until              
     ⌊  Floor            Minimum                     ∙  Inner Product                                                                                                                                        
     ⍟  Logarithm        BaseLogarithm               ⌻  Outer Product            
     ⍳  Iota             IndexOf                     ˝  Functional Inverse                                                                                                                                            
     ⍴  Shape            Reshape                     ∘  Compose                 
     ⊢  Self             Right                       ⍛  Inverse Compose         
     ⊣  Self             Left                        ⍤  Rank                    
     =                   Equals                      ⍥  Over                    
     ≠  Unique Mask      Not equals                  ⍢  Under                   
     <  Rank Up          Less than                   ⍫  Obverse                 
     >  Rank Down        Greater than                ∵  Derive Bitwise          
     ≤                   Less than or equal          ∥  Parallel                
     ≥                   Greater than or equal       λ  Function Reference      
     ⌷  List To Array    Index                       ⍞  Apply                   
     ⊂  Encose           Partition                   ⍰  Conditional Null Call   
     ⊃  Disclose         Pick                                                   
     ∧  Sort Increasing  And/GCD                        Control                 
     ∨  Sort Decreasing  Or/LCM                                                 
     ⍲                   Nand                          if (a) {                 
     ⍱                   Nor                                result              
     ~  Not              Without                       }                        
     ,  Ravel            Catenate                                               
     ⍪  Table            ,[0]                          if (a) {                 
     ↑  Take First       Take                               resultIfTrue        
     ↓  Drop First       Drop                          } else {                 
     ?  Random           Draw                               resultIfFalse       
     ⌽  Reverse          Rotate                                                 
     ⊖  Reverse First    Rotate First                  }                        
     ⍉  Transpose        Reorder                                                
     ≡  Depth            Match                         when {                   
     ≢  Tally            Not Match                        (conditionA) { resultIfA } 
     ∊  Enlist           Membership                       (conditionB) { resultIfB } 
     ⍷                   Find                             (1)          { elseResult }
     ⍋  Grade Up                                       }                             
     ⍒  Grade Down                                                                   
     /  Reduce           Replicate                     while (a) {                   
     ⌿  Reduce First     Replicate First                  code                       
     ⍕  Format           Format With Pattern           }                             
     ⍎  Parse Number                                                                 
     ∪  Unique           Union                         unwindProtect {               
     ∩                   Intersect                        mainCode                   
     !  Factorial        Binomial                      } { unwind }                  
                                     
                                                       a → b  ⍝ same as if (a) { →b }
                                                       
                                                       throw (errorstring)  
"
m ← m map:with "←" "
  LEFT ARROW ←

  Keyboard: `[

  Dyadic: Assign, bind a variable name to a value. The shorthand expression v +← 1 means v ← v + 1

  
  v ← 1 2 3 4         (i (j k)) ← (10 (11 12))         f ← λ-
┌→──────┐           ┌→─────────┐                     function  
│1 2 3 4│           │10 ┌→────┐│
└───────┘           │   │11 12││
  v +← 1            │   └─────┘│
┌→──────┐           └──────────┘
│2 3 4 5│
└───────┘  
"
m ← m map:with "⇐" "
  LEFT FAT ARROW ⇐

  Keyboard: `U    

  Dyadic: Assign to function, bind a variable name to a function.
 
  Note that lambda functions are assigned with ← and not ⇐

      
  f ⇐ +⌿
⍬  
  f ⇐ { (⍵+⍺)÷2 }
⍬  
"
m ← m map:with "⟦" "
  LEFT FAT BRACKET ⟦

  Keyboard: `5

  Function argument list open: When you call a function, you use fat brackets to input function arguments. 
  The given list is treated as having a length of 1, as opposed to calling a function with N-tuple, which
  has length N.
  

  ∇ foo (a;b;c) { a+b+c } ⋄ foo ⟦1;2;foo ⟦10;11;12⟧⟧
36  
"
m ← m map:with "⟧" "
  RIGHT FAT BRACKET ⟧

  Keyboard: `6

  Function argument list close: When you call a function, you use fat brackets to input function arguments. 
  The given list is treated as having a length of 1, as opposed to calling a function with N-tuple, which
  has length N.


  ∇ foo (a;b;c) { a+b+c } ⋄ foo ⟦1;2;foo ⟦10;11;12⟧⟧
36  
"
m ← m map:with "+" "
  PLUS +

  Monadic function: Complex conjugate
   
  + 1.2 0j4 ¯5j¯6 
┌→────────────────────┐
│1.2 0.0J-4.0 -5.0J6.0│
└─────────────────────┘


  Dyadic function: Addition

  1 2 3 4 + 10           1 2 3 + 2 ¯4 1           +/ 1 2 3   
┌→──────────┐          ┌→─────┐                 6  
│11 12 13 14│          │3 -2 4│
└───────────┘          └──────┘
"
m ← m map:with "-" "
  MINUS -

  Monadic function: Negate 
 
  - 3.2 ¯7 0 
┌→───────┐
│-3.2 7 0│
└────────┘
 

  Dyadic function: Subtraction 
 
  3 7 9 - 5           5 1 4 - 2 3 4  
┌→─────┐            ┌→─────┐  
│-2 2 4│            │3 -2 0│
└──────┘            └──────┘ 
"
m ← m map:with "×" "
  TIMES ×

  Keyboard: `-

  Monadic function: Direction, gives the sign of the number with magnitude 1 
 
  × 3.1 ¯2 0 3j4 
┌→─────────────┐
│1 -1 0 0.6J0.8│
└──────────────┘
 
  
  Dyadic function: Multiplication
 
  2 ¯3 4.5 × ¯3 ¯4 2           3 1 4 × 10            ×/ 2 3 4   
┌→────────┐                  ┌→───────┐            24   
│-6 12 9.0│                  │30 10 40│
└─────────┘                  └────────┘
"
m ← m map:with "÷" "
  DIVIDE ÷

  Keyboard: `=

  Monadic function: Reciprocal 
 
  ÷ 1 2 3 
┌→────────┐
│1 1/2 1/3│
└─────────┘
 

  Dyadic function: Division
 
  1 2 3 ÷ 4 5 7               10 ÷ ¯2 0.5 
┌→────────────────┐         ┌→──────┐  
│0.25 0.4 0.428571│         │-5 20.0│ 
└─────────────────┘         └───────┘
"
m ← m map:with "*" "
  STAR *

  Monadic function:  Exponential 
 
  * 0 1 2 
┌→─────────────────────────────────────┐
│1.0 2.718281828459045 7.38905609893065│
└──────────────────────────────────────┘
 

  Dyadic function:   Power 
 
  49 5 ¯4 * 0.5 2 0.5 
┌→────────────────────────────────┐
│7.0 25 1.2246467991473532E-16J2.0│
└─────────────────────────────────┘
"
m ← m map:with "⍟" "
  LOG ⍟

  Keyboard: `*

  Monadic function: Natural Logarithm, base e
 
  ⍟ 1 2 3 2.7182818285 
┌→───────────────────────────────────────────────────────────┐
│0.0 0.6931471805599453 1.0986122886681096 1.0000000000150664│
└────────────────────────────────────────────────────────────┘

 
  Dyadic function: Logarithm, base given as argument 
 
  2 10 ⍟ 32 1000 
┌→─────────────────────┐
│5.0 2.9999999999999996│
└──────────────────────┘
"
m ← m map:with "√" "
  ROOT √

  Keyboard: `R

  Monadic function: Square root

  √2 4 9
┌→─────────────────────────┐
│1.4142135623730951 2.0 3.0│
└──────────────────────────┘


  Dyadic function: n`th root, order n given as argument

  2 3 4 √49 8 10000
┌→───────────┐
│7.0 2.0 10.0│
└────────────┘
"
m ← m map:with "⌹" "
  DOMINO ⌹

  Keyboard: `+

  Monadic function: Matrix Inverse 
 
  mat ← 2 2⍴1+⍳4        ⌹ mat 
┌→──┐                 ┌→──────────────────────────────────────┐  
↓1 2│                 ↓-2.0000000000000004  1.0000000000000009│
│3 4│                 │ 1.5000000000000002 -0.5000000000000007│
└───┘                 └───────────────────────────────────────┘

 
  Dyadic function: Matrix Divide, solves a set of equations by multiplying by inverse matrix. 
  If we have m×n matrix A, n×1 vector x and m×1 vector b, the equation set A+∙×x=b has a solution
  x=(⌹A)+∙×b provided that A is invertible.

  Dyadic form computes the solution: b ⌹ A
 
  5 6 ⌹ mat 
┌→─────────────────────────────────────┐
│-3.9999999999999964 4.4999999999999964│
└──────────────────────────────────────┘
"
m ← m map:with "○" "
  CIRCLE ○

  Keyboard: `o

  This symbol is currently not used. It is used in other APLs with math functions.

"
m ← m map:with "!" "
  EXCLAMATION MARK !

  Monadic function:  Factorial, !n computes the Gamma function
  of n+1.
 
  ! 3 9 ¯0.11 
┌→──────────────────────────────┐
│6.0 362880.0 1.0768306828299132│
└───────────────────────────────┘
 

  Dyadic function: Binomial, computes the Binomial multipliers. It satisfies the following identity 
  with Beta function: β(A,B) is identical to ÷B×(A-1)!A+B-1
 
  2 1 3 ! 3 10 ¯0.11 
┌→────────────────────────┐
│3 10 -0.04293849999999995│
└─────────────────────────┘
"
m ← m map:with "?" "
  QUESTION MARK ? 

  Monadic function:  Roll, generate pseudorandom numbers. In the expression ? Array, where Array is any 
  array of positive integers, each element A of Array yields a pseudorandom value from the range ⍳A. 
  The result is an array with the same shape as Array.

  ? 6 6 6 6 6           ? 0 0   ⍝ generates numbers between 0 and 1 
┌→────────┐           ┌→────────────────────────────────────┐  
│3 3 5 0 4│           │0.648102338112447 0.46703844207153233│
└─────────┘           └─────────────────────────────────────┘
 
 
  Dyadic function: Deal, generate a sequence of unique numbers. The expression (Number ? Limit) produces 
  as many pseudo-random integer values as specified by Number, all among ⍳Limit, and all different. 
  For this reason, Number cannot be greater than Limit.
 
  7 ? 52  ⍝ deal a hand of 7 cards
┌→───────────────────┐
│25 40 31 14 44 16 42│
└────────────────────┘
"
m ← m map:with "|" "
  STILE |

  Monadic function:  Magnitude (Absolute value) 
 
  | 2.3 ¯4 0 3j4 
┌→──────────┐
│2.3 4 0 5.0│
└───────────┘
 

  Dyadic function: Residue (Remainder/Modulus), denoted by |, computes the remainder of a division. 
  In the expression R ← X|Y, R is the remainder when Y is divided by X (note that the arguments are 
  reversed compared to the division expression Y÷X).
 
  2 10 ¯2.5 | 7 ¯13 8 
┌→───────┐
│1 7 -2.0│
└────────┘
"
m ← m map:with "⌈" "
  UPSTILE ⌈

  Keyboard: `s

  Monadic function:  Ceiling, rounds its argument up to the nearest larger integer value.
 
  ⌈ 3.4 ¯3.4 3 0 
┌→───────┐
│4 -3 3 0│
└────────┘
 

  Dyadic function: Maximum, return the larger of two values, whatever their signs.
 
  1.1 ¯2 ⌈ 8.1 ¯3.4 
┌→───────┐
│8.1 -2.0│
└────────┘
 
  ⌈/ 3 1 4 1 
4 
"
m ← m map:with "⌊" "
  DOWNSTILE ⌊  

  Keyboard: `d

  Monadic function: Floor, rounds its argument down to the nearest smaller integer value.
 
  ⌊ 3.4 ¯3.4 3 0 
┌→───────┐
│3 -4 3 0│
└────────┘
 
  Dyadic function: Minimum, return the smaller of two values, whatever their signs.
 
  1.1 ¯2 ⌊ 8.1 ¯3.4          ⌊/ 3 1 4 1  
┌→───────┐                 1  
│1.1 -3.4│
└────────┘
"
m ← m map:with "⊥" "
  UP TACK ⊥

  Keyboard: `b

  Dyadic function: Decode a non-decimal representation into decimal one. Left argument is base and 
  right argument is the value in that base. 
 
  2 ⊥ 1 1 0 1   ⍝ binary decode 
13 
 
  Base does not have to be all in same radix. For example, here is the conversion of 2 hours, 27 minutes 
  and 19 seconds to seconds: 
 
  24 60 60 ⊥ 2 27 19 
8839
"
m ← m map:with "⊤" "
  DOWN TACK ⊤

  Keyboard: `n

  Dyadic function: Encode a decimal representation into non-decimal one. Left argument is base and right 
  argument is the value in that base.
 
  6 6 6 ⊤ 105 ⍝ encode to base 6           2 2 2 2 ⊤ 5 7 12   ⍝ binary encode, note the result as columns
┌→────┐                                  ┌→────┐  
│2 5 3│                                  ↓0 0 1│
└─────┘                                  │1 1 1│
                                         │0 1 0│
                                         │1 1 0│
                                         └─────┘ 

  Base does not have to be all in same radix. For example, here is the conversion of 10000 seconds to 
  hours, minutes and seconds:  

  24 60 60 ⊤ 10000 
┌→──────┐
│2 46 40│
└───────┘
"
m ← m map:with "⊣" "
  LEFT TACK ⊣

  Keyboard: `|

  Monadic function: Hide, forces evaluation of its argument to ensure that all side effects are called and in 
  the correct order. Then returns an empty 1-dimensional array with null fill value. This value will not be 
  printed in the REPL, making this function useful when the side effects of an expression are desired, but 
  there is no need to print the results.

  ⊣ 1 2 3


  Dyadic function: Left, always returns the left argument. The argument may be any array. 
 
  \"L\" ⊣ \"R\" 
L 
  ⊣/ 1 2 3 
1 
"
m ← m map:with "⊢" "
  RIGHT TACK ⊢

  Keyboard: `\

  Monadic function: Same, always returns the right argument. The argument may be any array. 
 
  ⊢ 1 2 3 
┌→────┐
│1 2 3│
└─────┘
 
  Dyadic function: Right, always returns the right argument. The argument may be any array.  
 
  \"L\" ⊢ \"R\" 
R 
  ⊢/ 1 2 3 
3 
"
m ← m map:with "⌸" "
  KEY ⌸

  Keyboard: `k 

  Dyadic function: Key will group identical major cells together, akin to SQL's GROUP BY statement. 
  Left and right arguments need to be of same size.

  \"Mississippi\" ⌸ (1 2 3 4 5 6 7 8 9 10 11)
┌→────────────┐
↓@M        ┌→┐│
│          │1││
│          └─┘│
│@i ┌→───────┐│
│   │2 5 8 11││
│   └────────┘│
│@s  ┌→──────┐│
│    │3 4 6 7││
│    └───────┘│
│@p     ┌→───┐│
│       │9 10││
│       └────┘│
└─────────────┘
"
m ← m map:with "=" "
  EQUAL =

  Dyadic function: Equal To, a comparison function which tests whether argument elements are tolerantly equal. 
  Returns 1 when equal and 0 when not. Compared arrays must be of equal size or one of the arguments is a scalar.
 
  1 2 3 = 4 2 ¯1           0 1 0 1 = 0 0 1 1  
┌→────┐                  ┌→──────┐  
│0 1 0│                  │1 0 0 1│
└─────┘                  └───────┘
  
  Note how it won't accept \"Banana\" = \"a\", because \"a\" is an array of size 1 and not a scalar:

  \"Banana\" = @a          7 = \"7\" 
┌→──────────┐            ┌→┐  
│0 1 0 1 0 1│            │0│
└───────────┘            └─┘
"
m ← m map:with "≠" "
  NOT EQUAL ≠

  Keyboard: `8

  Monadic function: Unique Mask aka. Nub Sieve, returns a boolean vector indicating all cells which do not 
  match any earlier indicated cell.
 
  ≠ \"Banana\"                      ≠ \"Mississippi\"
┌→──────────┐                   ┌→────────────────────┐  
│1 1 1 0 0 0│                   │1 1 1 0 0 0 0 0 1 0 0│
└───────────┘                   └─────────────────────┘ 
 
 
  Dyadic function: Not Equal To, a comparison function which tests whether argument elements 
  are tolerantly unequal. It is the boolean negation of Equal To.
 
  1 2 3 ≠ 4 2 ¯1           0 1 0 1 ≠ 0 0 1 1           \"Banana\" ≠ @a 
┌→────┐                  ┌→──────┐                   ┌→──────────┐  
│1 0 1│                  │0 1 1 0│                   │1 0 1 0 1 0│
└─────┘                  └───────┘                   └───────────┘ 
  
  7 ≠ \"7\" 
1 
"
m ← m map:with "≤" "
  LESS THAN OR EQUAL TO ≤

  Keyboard: `4

  Dyadic function: Less Than or Equal To, a comparison function which tests whether the left argument 
  is tolerantly less than or equal to the right argument, returning 1 if this is the case and 0 otherwise. 
  It is the negation of Greater Than >.
 
  1 2 3 ≤ 4 2 ¯1           1 2 3 ≤ 2  
┌→────┐                  ┌→────┐  
│1 1 0│                  │1 1 0│
└─────┘                  └─────┘
"
m ← m map:with "<" "
  LESS THAN <

  Monadic function: Increase Rank (Promote), adds a length-1 axis to its argument before the other axes, 
  resulting in an array with rank one higher.

 Array        Its rank

  <@a          ⍴\"a\"
\"a\"          ┌→┐
             │1│
             └─┘
           
 <\"a\"        ⍴<\"a\"         
┌→┐          ┌→──┐
↓a│          │1 1│
└─┘          └───┘


  Dyadic function: Less Than, a comparison function which tests whether the left argument is tolerantly 
  less than the right argument, returning 1 if this is the case and 0 otherwise.
 
  1 2 3 < 4 2 ¯1            1 2 3 < 2  
┌→────┐                   ┌→────┐  
│1 0 0│                   │1 0 0│
└─────┘                   └─────┘
"
m ← m map:with ">" "
  GREATER THAN >

  Monadic function: Decrease Rank, the inverse operation of Increase Rank. Removes a length-1 axis from its 
  argument before the other axes, resulting in an array with rank one lower. It will result in reshaping the
  array. The lowest rank of array with data in it will be one.

   Array                  Its rank
---------------------|-------------------
  2 2 2⍴⍳8           |    ⍴2 2 2⍴⍳8
┌┌→──┐               |  ┌→────┐   
│↓0 1│               |  │2 2 2│
││2 3│               |  └─────┘
│├→──┤               |
│↓4 5│               |
││6 7│               |
└└───┘               |
  >2 2 2⍴⍳8          |    ⍴>2 2 2⍴⍳8  
┌→──┐                |  ┌→──┐
↓0 1│                |  │4 2│
│2 3│                |  └───┘
│4 5│                |
│6 7│                |
└───┘                |
  >>2 2 2⍴⍳8         |    ⍴>>2 2 2⍴⍳8
┌→──────────────┐    |  ┌→┐
│0 1 2 3 4 5 6 7│    |  │8│
└───────────────┘    |  └─┘


  Dyadic function: Greater Than, a comparison function which tests whether the left argument is tolerantly 
  greater than the right argument, returning 1 if this is the case and 0 otherwise. 
 
  1 2 3 > 4 2 ¯1           1 2 3 > 2  
┌→────┐                  ┌→────┐  
│0 0 1│                  │0 0 1│ 
└─────┘                  └─────┘
"
m ← m map:with "≥" "
  GREATER THAN OR EQUAL TO ≥

  Keyboard: `6

  Dyadic function: Greater Than or Equal To, a comparison function which tests whether the left argument 
  is tolerantly greater than or equal to the right argument, returning 1 if this is the case and 0 otherwise. 
  It is the negation of Less Than <.
 
  1 2 3 ≥ 4 2 ¯1           1 2 3 ≥ 2  
┌→────┐                  ┌→────┐  
│0 1 1│                  │0 1 1│
└─────┘                  └─────┘
"
m ← m map:with "≡" "
  EQUAL UNDERBAR ≡

  Keyboard: `:

  Monadic function: Depth, returns an array's depth. The depth of an array is the number of levels 
  of nesting or boxing it exhibits. A simple scalar has a Depth of 0.
  A simple array (all items are simple scalars) has a Depth of 1.
  For any other array, Depth equals the deepest item’s Depth + 1.
 
  ≡ 7 
0 
  ≡ \"abc\"
1 
  ≡ (1 2)(3 4) 
2 
  ≡ (1 2)(3 4) 5 
2 
 
  Dyadic function: Match, indicates whether the left and right argument arrays are identical in same
  depth and shape. The result of Match is always a Boolean scalar: it is 1 if the arrays match and 0 
  otherwise.
 
  \"b\" \"e\" \"x\" ≡ \"bex\" 
0
  1 ≡ 1 1 
0 
"
m ← m map:with "≢" "
  EQUAL UNDERBAR SLASH ≢

  Keyboard: `\"

  Monadic function: Tally counts the major cells in its argument. For an array, this equals the leftmost 
  element of its shape vector (column length in rank 2); for a scalar, it returns 1 (as a scalar is 
  considered its own major cell).
 
  ≢ \"a\"           ≢ 5 4 3⍴0                mat ← 2 3⍴⍳6       ≢ mat   ⍝ note how \"tally\" 
1               5                        ┌→────┐            2  
  ≢ 7 4 2         ≢ (1 2)(3 4)           ↓0 1 2│              ⍴ mat   ⍝ differs from \"shape\" 
3               2                        │3 4 5│            ┌→──┐
                                         └─────┘            │2 3│
                                                            └───┘ 

 
  Dyadic function: Not Match, the boolean negative of Match. Returns 1 if the arguments are not identical,
  0 otherwise.
 
  \"b\" \"e\" \"x\" ≢ \"bex\"   
1
  1 ≢ 1 1 
1 
"
m ← m map:with "∨" "
  LOGICAL OR ∨

  Keyboard: `9
 
  Monadic function: Sort Decreasing, orders the major cells of an array in descending order. 

  ∨\"Canberra\" \"Paris\" \"Washington\" \"Moscow\" \"Martigues\" \"Mexico\"
┌→────────────────────────────────────────────────┐
│Washington Paris Moscow Mexico Martigues Canberra│
└─────────────────────────────────────────────────┘

  a←5?25                    ∨a
┌→─────────────┐          ┌→─────────────┐         
│11 18 17 15 24│          │24 18 17 15 11│
└──────────────┘          └──────────────┘


  Dyadic function: Logical OR, returns 1 if either of the arguments are 1, 0 if both are 0.
 
  0 1 0 1 ∨ 0 0 1 1 
┌→──────┐
│0 1 1 1│
└───────┘ 
"
m ← m map:with "∧" "
  LOGICAL AND ∧

  Keyboard: `0

  Monadic function: Sort Increasing, orders the major cells of an array in ascending order. 

  ∧\"Canberra\" \"Paris\" \"Washington\" \"Moscow\" \"Martigues\" \"Mexico\"
┌→────────────────────────────────────────────────┐
│Canberra Martigues Mexico Moscow Paris Washington│
└─────────────────────────────────────────────────┘

  a                     ∧a
┌→──────────┐         ┌→──────────┐  
│0 17 22 8 2│         │0 2 8 17 22│
└───────────┘         └───────────┘ 
  

  Dyadic function: Logical AND, returns 1 if both of the arguments are 1, 0 otherwise.
 
  0 1 0 1 ∧ 0 0 1 1 
┌→──────┐
│0 0 0 1│
└───────┘
"
m ← m map:with "⍲" "
  LOGICAL NAND ⍲

  Keyboard: `)

  Dyadic function: NAND, the boolean negation of AND. Returns 1 if either argument is 0, 0 if both are 1.
 
  0 1 0 1 ⍲ 0 0 1 1 
┌→──────┐
│0 0 0 1│
└───────┘
"
m ← m map:with "⍱" "
  LOGICAL NOR ⍱

  Keyboard: `(

  Dyadic function: NOR, the boolean negation of OR. Returns 1 if both arguments are 0, 0 otherwise.
 
  0 1 0 1 ⍱ 0 0 1 1 
┌→──────┐
│1 0 0 0│
└───────┘
"
m ← m map:with "↑" "
  UP ARROW ↑

  Keyboard: `y

  Monadic function: Take First, returns the first element in the array.
 
  ↑ (6 4) 5 3           ↑2 2⍴3+⍳4  
┌→──┐                 3  
│6 4│
└───┘


  Dyadic function: Take, shortens or extends the right argument array along zero or more axes. 
  The vector left argument indicates the lengths of result axes, with a sign to denote whether 
  elements should be taken starting from the beginning or end of each axis. 
 
  4 ↑ \"Pineapple\"           ¯5 ↑ \"Pineapple\"
\"Pine\"                    \"apple\"   

  Selecting sections from a 2-dimensional array:

   Array         Top Right       Bottom         Bottom Left
 
  mat←3 4⍴⍳12     2 ¯3 ↑ mat      ¯2 ↑ mat       ¯2 3 ↑ mat     
┌→────────┐     ┌→────┐         ┌→────────┐     ┌→─────┐
↓0 1  2  3│     ↓1 2 3│         ↓4 5  6  7│     ↓4 5  6│
│4 5  6  7│     │5 6 7│         │8 9 10 11│     │8 9 10│
│8 9 10 11│     └─────┘         └─────────┘     └──────┘
└─────────┘
"
m ← m map:with "↓" "
  DOWN ARROW ↓

  Keyboard: `u

  Monadic function: Drop First, returns all other elements except the first one. 
  In a multidimensional case, removes one element from the leftmost axis. 
 
  mat←3 4⍴⍳12                  mat2←2 2 2⍴⍳8
┌→────────┐                  ┌┌→──┐
↓0 1  2  3│                  │↓0 1│
│4 5  6  7│                  ││2 3│
│8 9 10 11│                  │├→──┤
└─────────┘                  │↓4 5│
                             ││6 7│
  ↓ mat  ⍝ remove 1st row    └└───┘
┌→────────┐                    ↓ mat2   ⍝ remove 1st 2by2 matrix
↓4 5  6  7│                  ┌┌→──┐
│8 9 10 11│                  │↓4 5│
└─────────┘                  ││6 7│
                             └└───┘
 
  Dyadic function: Drop, removes part of each axis of an array. The removed portions are exactly 
  those that Take would include in its result. 
 
  4 ↓ \"Pineapple\"           ¯5 ↓ \"Pineapple\"
\"apple\"                   \"Pine\"

  1 ¯2 ↓ mat               1 ↓ mat 
┌→──┐                    ┌→────────┐
↓4 5│                    ↓4 5  6  7│
│8 9│                    │8 9 10 11│
└───┘                    └─────────┘ 
"
m ← m map:with "⊂" "
  LEFT SHOE ⊂

  Keyboard: `z

  Monadic function: Enclose, creates a nested scalar by wrapping its argument under one level of nesting. 
  With axis modifier can be used to move one or more axes to an extra level of nesting.  

  1 (2 3)        |   a←2 3 4⍴\"ABCDEFGHIJKLMNOPQRSTUVWX\"         ⊂[0]a 
┌→──────┐        |   ┌┌→───┐                                  ┌→──────────┐  
│1 ┌→──┐│        |   │↓ABCD│                                  ↓AM BN CO DP│
│  │2 3││        |   ││EFGH│       ⊂[2]a                      │EQ FR GS HT│
│  └───┘│        |   ││IJKL│     ┌→─────────────┐             │IU JV KW LX│
└───────┘        |   │├→───┤     ↓ABCD EFGH IJKL│             └───────────┘
  ⊂ 1 (2 3)      |   │↓MNOP│     │MNOP QRST UVWX│               ⊂[1]a
┌─────────┐      |   ││QRST│     └──────────────┘             ┌→──────────────┐
│┌→──────┐│      |   ││UVWX│                                  ↓AEI BFJ CGK DHL│
││1 ┌→──┐││      |   └└────┘                                  │MQU NRV OSW PTX│
││  │2 3│││      |                                            └───────────────┘
││  └───┘││      |
│└───────┘│      | 
└─────────┘      |
 

  Dyadic function: Partitioned Enclose, a dyadic function which splits its right argument into differently 
  sized pieces as determined by the left argument. Partition begins a new division of its right argument 
  whenever a left argument element is greater than its neighbour on the left (with a 0 ignoring the element): 

  0 1 1 2 ⊂ 1 2 3 4 
┌→────────┐
│┌→──┐ ┌→┐│
││2 3│ │4││
│└───┘ └─┘│
└─────────┘ 
"
m ← m map:with "⊃" "
  RIGHT SHOE ⊃

  Keyboard: `x

  Monadic function: Disclose, a monadic function which reduces the level of nesting of an array. 
 
  (1 2)(3 4 5)        ⊃ (1 2)(3 4 5) 
┌→────────────┐     ┌→────┐  
│┌→──┐ ┌→────┐│     ↓1 2 0│
││1 2│ │3 4 5││     │3 4 5│
│└───┘ └─────┘│     └─────┘
└─────────────┘


  Dyadic function: Pick, performs deep indexing on a possibly nested array. Pick allows to extract a 
  value through multiple layers of nesting in a single function application. 
 
  3 ⊃ \"Word\" 
@d  
  1 ⊃ (1 2)(3 4 5) 
┌→────┐
│3 4 5│
└─────┘
  1 0 ⊃ (1 2)(3 4 5) 
3
"
m ← m map:with "⊆" "
  LEFT SHOE UNDERBAR ⊆

  Keyboard: `Z

  Monadic function: Nest, applies Enclose to the given argument, but only if it is simple. 
 
  ⊆ 1 2 3       ⊆ (1 2 3)             ⊂⊂ (1 2 3)          ⊆⊆ (1 2 3)
┌───────┐         ┌───────┐         ┌─────────┐         ┌───────┐  
│┌→────┐│         │┌→────┐│         │┌───────┐│         │┌→────┐│ 
││1 2 3││         ││1 2 3││         ││┌→────┐││         ││1 2 3││
│└─────┘│         │└─────┘│         │││1 2 3│││         │└─────┘│
└───────┘         └───────┘         ││└─────┘││         └───────┘
                                    │└───────┘│
                                    └─────────┘
 

  Dyadic function: Partition, splits its right argument into differently sized pieces as determined 
  by the non-negative integer left argument. On a vector right argument, the arguments must have the 
  same length with each element in the left argument corresponding to an element in the right argument. 
  The corresponding element in the left argument indicates where divisions begin: 

  1 0 1 0 0 0 0⊆\"HiEarth\"
┌→───────────┐
│\"Hi\" \"Earth\"│
└────────────┘ 
"
m ← m map:with "⌷" "
  SQUAD ⌷

  Keyboard: `L

  Monadic function: List To Array, return a 1-dimensional array with its content given an N-tuple.
 
  ⌷(:all ; :sorts ; :of ; :elements; 1 ; 2 ; :in ; :the ; 3 ; :list)
┌→─────────────────────────────────────────────┐
│:all :sorts :of :elements 1 2 :in :the 3 :list│
└──────────────────────────────────────────────┘
 

  Dyadic function: Index, X⌷Y returns an array formed with items of Y extracted by the index specification X. 
 
  mat               2 3 ⌷ mat           2 ⌷ mat            2 ⌷[1] mat  
┌→────────┐       11                  ┌→────────┐        ┌→─────┐  
↓0 1  2  3│                           │8 9 10 11│        │2 6 10│
│4 5  6  7│                           └─────────┘        └──────┘
│8 9 10 11│
└─────────┘

"
m ← m map:with "⍋" "
  GRADE UP ⍋

  Keyboard: `$

  Monadic function: Grade Up, returns a permutation vector whose length equals the number of major cells, 
  so that indexing into the argument gives the sorted array in ascending order. 
 
  ⍋ 33 11 44 66 22           names←\"Joe\" \"Sue\" \"Sam\"         {⍵[⍋⍵]} \"ABC\" ⍬ ¯3j4 \"A\" 
┌→────────┐                  ages←34 22 25                       ┌→───────────────┐  
│1 4 0 2 3│                  names[⍋ages]                        │-3.0J4.0 ⍬ A ABC│
└─────────┘                ┌→──────────┐                         └────────────────┘ 
                           │Sue Sam Joe│
                           └───────────┘                         
"
m ← m map:with "⍒" "
  GRADE DOWN ⍒

  Keyboard: `#

  Monadic function: Grade Down, returns a permutation vector whose length equals the number of major cells, 
  so that indexing into the argument gives the sorted array in descending order.  
 
  ⍒ 33 11 44 66 22           names←\"Joe\" \"Sue\" \"Sam\"         {⍵[⍒⍵]} \"ABC\" ⍬ ¯3j4 \"A\"
┌→────────┐                  ages←34 22 25                       ┌→───────────────┐  
│3 2 0 4 1│                  names[⍒ages]                        │ABC A ⍬ -3.0J4.0│
└─────────┘                ┌→──────────┐                         └────────────────┘ 
                           │Joe Sam Sue│
                           └───────────┘
"
m ← m map:with "≬" "
  BETWEEN ≬

  Keyboard: `Y

  Monadic function: Array To List, return an N-tuple made out of 1-dimensional array.

  ≬ :all :sorts :of :elements 1 2 :in :the 3 :list
╔════╤══════╤═══╤═════════╤═╤═╤═══╤════╤═╤═════╗
║:all│:sorts│:of│:elements│1│2│:in│:the│3│:list║
╚════╧══════╧═══╧═════════╧═╧═╧═══╧════╧═╧═════╝
"
m ← m map:with "⫇" "
  LEFT SHOE TILDE ⫇

  Keyboard: `Q

  Dyadic function: Group Elements By Index. A is a 1-dimensional array of integers, with length equal to the 
  tally of B. The result is a nested vector containing major cells of B, in the positions marked by corresponding
  entries in B. Cells that correspond to a negative number are dropped from the result. 

b←3 3 2 ⍴ ⍳18           0 1 0 ⫇ b
┌┌→────┐              ┌→────────────────┐  
│↓ 0  1│              │┌┌→────┐ ┌┌→────┐│
││ 2  3│              ││↓ 0  1│ │↓ 6  7││
││ 4  5│              │││ 2  3│ ││ 8  9││
│├→────┤              │││ 4  5│ ││10 11││
│↓ 6  7│              ││├→────┤ └└─────┘│
││ 8  9│              ││↓12 13│         │
││10 11│              │││14 15│         │
│├→────┤              │││16 17│         │
│↓12 13│              │└└─────┘         │
││14 15│              └─────────────────┘
││16 17│
└└─────┘
"
m ← m map:with "⍳" "
  IOTA ⍳

  Keyboard: `i 

  Monadic function: Index Generator,  returns an array of indices with shape given by the right argument. 
  In the result, the element at each index is that index. 
 
  ⍳10                           ⍳ 2 3 
┌→──────────────────┐         ┌→────────────────┐  
│0 1 2 3 4 5 6 7 8 9│         ↓┌→──┐ ┌→──┐ ┌→──┐│
└───────────────────┘         ││0 0│ │0 1│ │0 2││
                              │└───┘ └───┘ └───┘│
                              │┌→──┐ ┌→──┐ ┌→──┐│
                              ││1 0│ │1 1│ │1 2││
                              │└───┘ └───┘ └───┘│ 
                              └─────────────────┘

 
  Dyadic function: Index Of, returns an array of indices where each item in the right argument appears in 
  the left argument. If some item is not found, the corresponding index returned is one higher than the 
  last index of the left argument.
 
  \"ABCDABCDEF\" ⍳ \"ACF\"           mat             mat ⍳ 0 5     
┌→────┐                       ┌→──┐           ┌→──────────┐   
│0 2 9│                       ↓0 1│           │┌→──┐ ┌→──┐│
└─────┘                       │2 3│           ││0 0│ │2 1││
                              │4 5│           │└───┘ └───┘│
                              └───┘           └───────────┘
"
m ← m map:with "∊" "
  EPSILON ∊

  Keyboard: `e

  Monadic function: Enlist, returns a simple vector of all simple scalar values in a possibly nested array. 
  Enlist differs from Ravel in that Enlist flattens over all layers of nesting, while Ravel flattens only 
  the outermost layer. 

  ∊ 0 (⊂2 3⍴1+⍳6) (7 8) 9         ∊ 2 3⍴1 \"abc\" 
┌→──────────────────┐           ┌→───────────────────────────────┐
│0 1 2 3 4 5 6 7 8 9│           │1 @a @b @c 1 @a @b @c 1 @a @b @c│
└───────────────────┘           └────────────────────────────────┘
 
 
  Dyadic function: Membership, tests if each of the elements of the left argument appears as an element of 
  the right argument. Both arguments can be arrays of any shape. Each element of the left argument is tested 
  against elements of the right argument, and the result is a boolean array having the same shape as the left 
  argument. For nested arrays, Membership tests for exact match between the elements. 
 
  \"abc\" 4 ∊ 4 \"ab\" \"abcd\"                    mat                 mat ∊ 6 2 7 4 
┌→──┐                                      ┌→────────┐         ┌→──────┐  
│0 1│                                      ↓0 1  2  3│         ↓0 0 1 0│
└───┘                                      │4 5  6  7│         │1 0 1 1│
  \"abc\" 4 ∊ 4 \"abc\" \"abcd\"                 │8 9 10 11│         │0 0 0 0│
┌→──┐                                      └─────────┘         └───────┘
│1 1│
└───┘
"
m ← m map:with "⍷" "
  EPSILON UNDERBAR ⍷

  Keyboard: `E

  Dyadic function: Find, indicates where the left argument appears as a contiguous subarray of the right 
  argument. Both arguments can be arrays of any shape. The entire left argument is tested against each 
  position in the right argument. The result is a boolean array having the same shape as the right argument, 
  where a 1 indicates the position of the first element of the matched subarray.

  \"ana\" ⍷ \"Banana\"                        Y          X ⍷ Y 
┌→──────────┐                   X      ┌→──────┐    ┌→──────┐
│0 1 0 1 0 0│                 ┌→──┐    ↓0 1 0 0│    ↓1 0 0 0│
└───────────┘                 ↓0 1│    │1 0 0 1│    │0 0 1 0│
                              │1 0│    │0 0 1 0│    │0 1 0 0│
                              └───┘    │0 1 0 0│    │0 0 0 0│
                                       └───────┘    └───────┘
"
m ← m map:with "∪" "
  DOWN SHOE ∪

  Keyboard: `v

  Monadic function: Unique, removes duplicate major cells from an array. It returns only the distinct cells 
  (those which do not match an earlier distinct cell) in the order they appeared in the array. 
 
  ∪ \"ab\" \"ba\" \"ab\" 1 1 2 
┌→────────┐
│ab ba 1 2│
└─────────┘


  Dyadic function: Union, computes the set union of the two vector arguments. It returns only the distinct cells.

  1 2 3 1 2 3 1 2 3∪5 4 3 2 5 4 3 2            \"WASH\" ∪ \"SHOUT\"
┌→────────┐                                  \"WASHOUT\"  
│1 2 3 5 4│ 
└─────────┘                                    \"ab\" \"cde\" \"fg\" ∪ \"a\" \"ab\" 
                                            ┌→──────────┐  
                                            │ab cde fg a│
                                            └───────────┘ 
"                                     
m ← m map:with "∩" "
  UP SHOE ∩

  Keyboard: `c

  Dyadic function: Intersection, computes the set intersection of the two vector arguments. Both arguments of 
  Intersection is usually restricted to vectors. Unlike sets in the mathematical sense, duplicate elements are 
  allowed in both sides. It returns only the distinct cells.
 
  X←\"AABBCCCC\" ⋄ Y←\"AABBAA\" ⋄ X∩Y      
\"AB\"

  1 1 1 2 3 3 ∩ 3 3 4 4 4 5 5
┌→┐
│3│
└─┘
" 
m ← m map:with "~" "
  TILDE ~

  Monadic function: NOT, returns the logical negation of a Boolean argument; 0 if the argument is 1 
  and 1 if it is 0. 
 
  ~ 0 1 0 1 
┌→──────┐
│1 0 1 0│
└───────┘
 

  Dyadic function: Without, computes the set difference of the two vector arguments. Both arguments are 
  usually restricted to vectors. Unlike sets in the mathematical sense, duplicate elements are allowed in 
  both sides. Returns the elements of the left argument after the right argument elements have been removed. 
 
  1 1 1 2 3 3 ~ 3 3 4 4 4 5 5
┌→──────┐
│1 1 1 2│
└───────┘
 
  \"THE QUICK BROWN FOX\" ~ @Q @U
\"THE ICK BROWN FOX\

  \"THE QUICK BROWN FOX\" ~ \"QUICK\"
\"THE  BROWN FOX\"
"
m ← m map:with "/" "
  SLASH /

  Dyadic function: Replicate, copies each element of the right argument a given number of times, ordering the 
  copies along a specified axis. Left argument cannot be negative.
 
  1 0 1 0 1 / \"Heart\"              1 5 0 0 1 / \"Heart\"
\"Hat\"                            \"Heeeeet\"

  
  Monadic operator: Reduce (Fold), takes a dyadic function operand, inserts it between the elements of the 
  argument, and evaluates it into a single array in right-to-left order. When applied to a vector argument, 
  f/1 2 3 4, it evaluates the expression 1 f 2 f 3 f 4. If given an extra integer left argument, the right
  vector argument will be evaluated windowed, where the left integer is the size of the window.
 
  +/ 1 2 3 4 5 ⍝ 1+2+3+4+5    3 +/ 1 2 3 4 5 ⍝ 3-window sum          2 +/ 1 2 3 4 5 ⍝ pair-wise sum
15                          ┌→─────┐                               ┌→──────┐
                            │6 9 12│                               │3 5 7 9│
                            └──────┘                               └───────┘   
  cube←2 3 4⍴⍳24
┌┌→──────────┐        +/ cube       +/[0] cube       +/[1] cube       +/[2] cube
│↓ 0  1  2  3│      ┌→───────┐    ┌→──────────┐    ┌→──────────┐    ┌→───────┐
││ 4  5  6  7│      ↓ 6 22 38│    ↓12 14 16 18│    ↓12 15 18 21│    ↓ 6 22 38│
││ 8  9 10 11│      │54 70 86│    │20 22 24 26│    │48 51 54 57│    │54 70 86│
│├→──────────┤      └────────┘    │28 30 32 34│    └───────────┘    └────────┘
│↓12 13 14 15│                    └───────────┘
││16 17 18 19│
││20 21 22 23│
└└───────────┘
"
m ← m map:with "\\" "
  BACKSLASH \

  Dyadic function: Expand, copies each element of the right argument a given number of times and inserts 
  prototype elements, ordering the copies along a specified axis. If the right argument is a vector, the 
  number of positive values in the left argument must match the length of the right argument. Each positive 
  value produces copies of the corresponding item on the right argument; a zero or negative value produces 
  one or more prototype elements. 
 
  3 ¯2 4 \ 7 8                1 0 1 0 1 \ \"Hat\"
┌→────────────────┐         ┌→───────────┐  
│7 7 7 0 0 8 8 8 8│         │@H 0 @a 0 @t│
└─────────────────┘         └────────────┘
 
   
  Monadic operator: Scan, takes a dyadic function operand and produces a monadic function which is equivalent 
  to the reductions of the prefixes of the arguments. Scan is similar to Reduce, however all the intermediate 
  results will be retained. That being said, unlike Reduce, Scan does not reduce the rank of its argument, i.e. 
  performing a scan over an N-dimensional array will produce an N-dimensional array. 
 
  +\ 1 2 3 4 5           mat←3 4⍴⍳12          +\mat ⍝ sideways      +\[0]mat ⍝ downwards
┌→──────────┐          ┌→────────┐          ┌→─────────┐          ┌→──────────┐    
│1 3 6 10 15│          ↓0 1  2  3│          ↓0  1  3  6│          ↓ 0  1  2  3│
└───────────┘          │4 5  6  7│          │4  9 15 22│          │ 4  6  8 10│
                       │8 9 10 11│          │8 17 27 38│          │12 15 18 21│
                       └─────────┘          └──────────┘          └───────────┘ 
"
m ← m map:with "⌿" "
  SLASH BAR ⌿

  Keyboard: `/

  Dyadic function: Replicate First (Compress First), copies each element of the right argument a given number of times, ordering the 
  copies along the first axis. Left argument cannot be negative. Replicate First differs from Replicate by
  operating on the first (innermost) axis, as opposed to the last axis.

  Chemistry←⍪\"H2SO4\" \"CaCO3\" \"Fe2O3\"     mat             1 0 2 ⌿ mat  ⍝ select first row once, last row twice
┌→──────┐                              ┌→────────┐     ┌→────────┐  
↓ H2SO4 │       0 1 0 ⌿ Chemistry      ↓0 1  2  3│     ↓0 1  2  3│
│ CaCO3 │     ┌→──────┐                │4 5  6  7│     │8 9 10 11│
│ Fe2O3 │     ↓ CaCO3 │                │8 9 10 11│     │8 9 10 11│
└───────┘     └───────┘                └─────────┘     └─────────┘
  

  Monadic operator: Reduce First, takes a dyadic function operand, inserts it between the elements of the 
  argument, and evaluates it along the first axis into a single array in right-to-left order. When applied 
  to a vector argument, f/1 2 3 4, it evaluates the expression 1 f 2 f 3 f 4. If given an extra integer left 
  argument, the right vector argument will be evaluated windowed, where the left integer is the size of the 
  window.
 
  mat                 +⌿ mat  ⍝ sum over columns     2 +⌿ mat  ⍝ windowed 2-sum over columns
┌→────────┐         ┌→──────────┐                  ┌→──────────┐  
↓0 1  2  3│         │12 15 18 21│                  ↓ 4  6  8 10│
│4 5  6  7│         └───────────┘                  │12 14 16 18│
│8 9 10 11│                                        └───────────┘
└─────────┘       
"
m ← m map:with "⍀" "
  BACKSLASH BAR ⍀

  Keyboard: `.

  Dyadic function: Expand First, copies each element of the right argument a given number of times and inserts 
  prototype elements, ordering the copies along the first axis. If the right argument is a vector, the 
  number of positive values in the left argument must match the length of the right argument. Each positive 
  value produces copies of the corresponding item on the right argument; a zero or negative value produces 
  one or more prototype elements.

  mat                      1 0 2 1 ⍀ mat  ⍝ select first row, then a row of zeros, then the second row twice
┌→────────┐              ┌→────────┐      ⍝ and then the third row once
↓0 1  2  3│              ↓0 1  2  3│
│4 5  6  7│              │0 0  0  0│
│8 9 10 11│              │4 5  6  7│
└─────────┘              │4 5  6  7│
                         │8 9 10 11│
                         └─────────┘

  Monadic operator: Scan First, takes a dyadic function operand and produces a monadic function which is equivalent 
  to the reductions of the prefixes of the arguments along the first axis. Scan is similar to Reduce, however all 
  the intermediate results will be retained. That being said, unlike Reduce, Scan does not reduce the rank of 
  its argument, i.e. performing a scan over an N-dimensional array will produce an N-dimensional array. 
 
  +⍀ mat   ⍝ intermediate column sums
┌→──────────┐
↓ 0  1  2  3│
│ 4  6  8 10│
│12 15 18 21│
└───────────┘
"
m ← m map:with "…" "
  ELLIPSIS …

  Keyboard: `m

  Dyadic function: Range, creates a vector of consecutive integers based on the start and end values given by its arguments. 
  
  3…8                   5…¯5
┌→──────────┐         ┌→─────────────────────────┐  
│3 4 5 6 7 8│         │5 4 3 2 1 0 -1 -2 -3 -4 -5│
└───────────┘         └──────────────────────────┘
"
m ← m map:with "," "
  COMMA ,

  Monadic function: Ravel, returns the vector containing all its elements in ravel order. It is equivalent to reshaping an 
  array using its bound for the new shape. Ravel works only on the outermost layer. If you need to completely removed
  array's structure and depth, use Enlist.

  cube←2 2 2⍴⍳8                   arr←⍳2 2 2           ,arr
┌┌→──┐                          ┌┌→──────────────┐  ┌→──────────────────────────────────────────────────────────────┐
│↓0 1│    ,cube                 │↓┌→────┐ ┌→────┐│  │┌→────┐ ┌→────┐ ┌→────┐ ┌→────┐ ┌→────┐ ┌→────┐ ┌→────┐ ┌→────┐│
││2 3│  ┌→──────────────┐       │││0 0 0│ │0 0 1││  ││0 0 0│ │0 0 1│ │0 1 0│ │0 1 1│ │1 0 0│ │1 0 1│ │1 1 0│ │1 1 1││
│├→──┤  │0 1 2 3 4 5 6 7│       ││└─────┘ └─────┘│  │└─────┘ └─────┘ └─────┘ └─────┘ └─────┘ └─────┘ └─────┘ └─────┘│
│↓4 5│  └───────────────┘       ││┌→────┐ ┌→────┐│  └───────────────────────────────────────────────────────────────┘
││6 7│                          ..................
└└───┘                          ││┌→────┐ ┌→────┐│
                                │││1 1 0│ │1 1 1││
                                ││└─────┘ └─────┘│
                                └└───────────────┘


  Dyadic function:   Catenate/Laminate (Join), combines two arrays along a shared axis, so that elements of the 
  left argument are followed by those of the right along that axis.  
 
  1 2 3 , 4 5 6         cube , 99          (<1 2 3) ,[0] (<4 5 6) ⍝ Laminate
┌→──────────┐         ┌┌→─────┐          ┌→────┐  
│1 2 3 4 5 6│         │↓0 1 99│          ↓1 2 3│
└───────────┘         ││2 3 99│          │4 5 6│
                      │├→─────┤          └─────┘ 
                      │↓4 5 99│
                      ││6 7 99│
                      └└──────┘
"
m ← m map:with "⍪" "
  COMMA BAR ⍪

  Keyboard: `<

  Monadic function: Table, returns a matrix formed by applying Ravel to each major cell of the given array. 
 
  ⍪ 2 3 4    cube←2 2 2⍴⍳8     ⍪ cube 
┌→┐        ┌┌→──┐            ┌→──────┐ 
↓2│        │↓0 1│            ↓0 1 2 3│
│3│        ││2 3│            │4 5 6 7│
│4│        │├→──┤            └───────┘
└─┘        │↓4 5│
           ││6 7│
           └└───┘  

 
  Dyadic function: Catenate First/Laminate, combines two arrays of matching shape along the first axis.
 
  mat←2 3⍴⍳6       mat ⍪ 0        mat ⍪ 7 8 9 
┌→────┐          ┌→────┐        ┌→────┐  
↓0 1 2│          ↓0 1 2│        ↓0 1 2│
│3 4 5│          │3 4 5│        │3 4 5│
└─────┘          │0 0 0│        │7 8 9│
                 └─────┘        └─────┘ 
"
m ← m map:with "⍮" "
  SEMICOLON UNDERBAR ⍮

  Keyboard: `>

  Monadic function: Singleton, creates a 1-dimensional array of size 1, containing the argument. 
  This function is the same as ,⊂

  ⍮1 2 3 4 5 6           ⍴⍮1 2 3 4 5 6
┌→────────────┐         ┌→┐  
│┌→──────────┐│         │1│
││1 2 3 4 5 6││         └─┘
│└───────────┘│
└─────────────┘


  Dyadic function: Pair, creates a 1-dimensional array of size 2, where the first element is A and the second 
  element is B. This function is the same as ,⍥⊂

    1 2 3 ⍮ 2 2⍴⍳4
┌→────────────┐
│┌→────┐ ┌→──┐│
││1 2 3│ ↓0 1││
│└─────┘ │2 3││
│        └───┘│
└─────────────┘
"
m ← m map:with "⍴" "
  RHO ⍴

  Keyboard: `r 

  Monadic function: Shape, return the shape of the argument. The return value is an array containing the size 
  of each dimension.
 
  cube           ⍴cube           ⍴⍴cube     ⍴ 7       ⍴⍴ 7 
┌┌→──┐         ┌→────┐         ┌→┐         ⍬         0 
│↓0 1│         │2 2 2│         │3│
││2 3│         └─────┘         └─┘
│├→──┤
│↓4 5│
││6 7│
└└───┘

  Dyadic function: Reshape, A⍴B reshapes B into the dimensions specified by A. The resulting array with have 
  ×/A elements. If the total number of elements in A is less than that of B, the extra elements will be dropped. 
  If the total number of elements in A is greater than that of B, the values will wrap around to fill the result 
  array. If B is scalar, every element of the resulting array will have this value.

  2 3 4 ⍴ 1 2 3 4 5 6 7 
┌┌→──────┐
│↓1 2 3 4│
││5 6 7 1│
││2 3 4 5│
│├→──────┤
│↓6 7 1 2│
││3 4 5 6│
││7 1 2 3│
└└───────┘
"
m ← m map:with "⌽" "
  CIRCLE STILE ⌽

  Keyboard: `%

  Monadic function: Reverse, reorders elements of the argument to go in the opposite direction along a specified axis.  

  mat                ⌽ mat              ⌽[0] mat 
┌→────────┐        ┌→────────┐        ┌→────────┐ 
↓0 1  2  3│        ↓ 3  2 1 0│        ↓8 9 10 11│
│4 5  6  7│        │ 7  6 5 4│        │4 5  6  7│
│8 9 10 11│        │11 10 9 8│        │0 1  2  3│
└─────────┘        └─────────┘        └─────────┘
 
  ⌽ \"trams\"
\"smart\"
  

  Dyadic function: Rotate, moves the elements of the right argument around a specified axis. A negative argument will
  rotate in opposite direction. When the right argument's rank is higher than 1, the left argument can be an array with 
  rank 1 smaller. It specifies different amounts of rotation for different \"columns\" or 1-dimensional subarrays which 
  Rotate is applied to. 
 
  4 ⌽ \"HatStand\"         ¯1 ⌽ mat         1 ¯1 2 ⌽ mat     0 1 2 ¯1 ⌽[0] mat 
\"tandHatS\"              ┌→────────┐      ┌→────────┐      ┌→────────┐ 
                        ↓ 3 0 1  2│      ↓ 1  2 3 0│      ↓0 5 10 11│
  ¯2 ⌽ 1 2 3 4 5 6      │ 7 4 5  6│      │ 7  4 5 6│      │4 9  2  3│
┌→──────────┐           │11 8 9 10│      │10 11 8 9│      │8 1  6  7│ 
│5 6 1 2 3 4│           └─────────┘      └─────────┘      └─────────┘
└───────────┘ 
" 
m ← m map:with "⊖" "
  CIRCLE BAR ⊖

  Keyboard: `&

  Monadic function: Reverse First, reorders elements of the argument to go in the opposite direction along 
  the first axis.  

  mat               ⊖ mat      ⍝ reverse row order
┌→────────┐       ┌→────────┐  
↓0 1  2  3│       ↓8 9 10 11│
│4 5  6  7│       │4 5  6  7│
│8 9 10 11│       │0 1  2  3│
└─────────┘       └─────────┘


  Dyadic function: Rotate First, moves the elements of the right argument around a specified axis. A negative argument will
  rotate in opposite direction. When the right argument's rank is higher than 1, the left argument can be an array with 
  rank 1 smaller. It specifies different amounts of rotation for different \"columns\" or 1-dimensional subarrays which 
  Rotate is applied to. 
 
  0 1 2 ¯1 ⊖ mat 
┌→────────┐
↓0 5 10 11│
│4 9  2  3│
│8 1  6  7│
└─────────┘
"
m ← m map:with "⍉" "
  TRANSPOSE ⍉

  Keyboard: `^

  Monadic function: Transpose, reorders the axes of the right argument array. 

  mat←3 2 4 ⍴⍳24         ⍴mat            ⍉mat               ⍴⍉mat
┌┌→──────────┐         ┌→────┐         ┌┌→──────┐         ┌→────┐
│↓ 0  1  2  3│         │3 2 4│         │↓0  8 16│         │4 2 3│
││ 4  5  6  7│         └─────┘         ││4 12 20│         └─────┘
│├→──────────┤                         │├→──────┤
│↓ 8  9 10 11│                         │↓1  9 17│
││12 13 14 15│                         ││5 13 21│
│├→──────────┤                         │├→──────┤
│↓16 17 18 19│                         │↓2 10 18│
││20 21 22 23│                         ││6 14 22│
└└───────────┘                         │├→──────┤
                                       │↓3 11 19│
                                       ││7 15 23│
                                       └└───────┘

  Dyadic function: Reorder axes, the left argument X must be a vector whose length equals the rank of the right argument 
  Y, and the elements must form a range so that ∧/X∊⍳1+⌈/X is satisfied. 

  0 1 2⍉mat              0 2 1⍉mat         1 0 2⍉mat               2 1 0⍉mat
┌┌→──────────┐         ┌┌→────┐          ┌┌→──────────┐          ┌┌→──────┐  
│↓ 0  1  2  3│         │↓ 0  4│          │↓ 0  1  2  3│          │↓0  8 16│
││ 4  5  6  7│         ││ 1  5│          ││ 8  9 10 11│          ││4 12 20│
│├→──────────┤         ││ 2  6│          ││16 17 18 19│          │├→──────┤
│↓ 8  9 10 11│         ││ 3  7│          │├→──────────┤          │↓1  9 17│
││12 13 14 15│         │├→────┤          │↓ 4  5  6  7│          ││5 13 21│
│├→──────────┤         ........          ││12 13 14 15│          ..........
│↓16 17 18 19│         ││18 22│          ││20 21 22 23│          │↓3 11 19│
││20 21 22 23│         ││19 23│          └└───────────┘          ││7 15 23│
└└───────────┘         └└─────┘                                  └└───────┘
"
m ← m map:with "¨" "
  DIAERESIS ¨

  Keyboard: `1

  Monadic operator: Each (Map), applies its operand to each element of the arguments, and returns an array whose 
  elements are the results. If two arguments are given, their elements are matched using conformability rules. 


  +/¨ (1 2 3 4)(5 6 7)    3 ↑¨ 1 2 (3 4) \"V\"                       1 2 3 ,¨ 99 
┌→────┐                  ┌→───────────────────────────────┐      ┌→───────────────────┐
│10 18│                  │┌→────┐ ┌→────┐ ┌→────┐ ┌→─────┐│      │┌→───┐ ┌→───┐ ┌→───┐│
└─────┘                  ││1 0 0│ │2 0 0│ │3 4 0│ │@V 0 0││      ││1 99│ │2 99│ │3 99││
                         │└─────┘ └─────┘ └─────┘ └──────┘│      │└────┘ └────┘ └────┘│
                         └────────────────────────────────┘      └────────────────────┘
"
m ← m map:with "⍨" "
  TILDE DIAERESIS ⍨

  Keyboard: `T

  Monadic operator (F⍨ x): Duplicate, derives a monadic function that calls F dyadically with x as arguments.
 
  Dyadic operator (x F⍨ y): Commute, derives a function which calls the underlying function with the arguments reversed. 


  ⍝ ⍺ ⍴ ⍵            ⍝ ⍵ ⍴ ⍺                ⍝ ⍵ ⍴ ⍵ 
  2 ⍴ 3              2 ⍴⍨ 3                 ⍴⍨ 3      
┌→──┐              ┌→────┐                ┌→────┐
│3 3│              │2 2 2│                │3 3 3│
└───┘              └─────┘                └─────┘ 
"
m ← m map:with "⍣" "
  STAR DIAERESIS ⍣

  Keyboard: `P

  Dyadic operator: Repeat/until, performs bounded looping and unbounded looping. 
  A call is of the form (f⍣g)Y, where

    f is a function, 
    g can be an array or a function.

  Repeat/until repeatedly applies f to Y based on the type of operand g:

    * Function: Must be dyadic and must return a boolean singleton. The previous iteration value is provided as the right 
    argument to f, and the current iteration value is given as the left argument. f is repeatedly applied until this function 
    returns 1.
    * Integer: f is applied g times to Y. If g is negative, then the inverse of f (if available) is applied.


  ⍝ function \"add 10\" applied 3 times        ⍝ compute the next 6 elements of the Fibonacci sequence
  ({⍵+10}⍣3) 5                               ({⍵,((↑¯2↑⍵)+(↑¯1↑⍵))}⍣6) (0 1)
35                                         ┌→───────────────┐
  ⍝ applying \"add 10\" zero times           │0 1 1 2 3 5 8 13│
  ({⍵+10}⍣0) 5                             └────────────────┘
5
"
m ← m map:with "∙" "
  BULLET ∙

  Keyboard: `C

  Dyadic operator: Inner Product, f∙g produces a dyadic function when applied with two dyadic functions. 
  It's a generalisation of the matrix product, allowing not just addition-multiplication, but any dyadic 
  functions given as operands.        

 
 1 2 3 +∙× 4 5 6          mat           mat +∙× mat  ⍝ matrix product 
32                      ┌→──┐         ┌→────┐
                        ↓1 2│         ↓ 7 10│
 3 ∧∙= 3 3 3 3          │3 4│         │15 22│
1                       └───┘         └─────┘
"
m ← m map:with "⌻" "
  QUAD JOT ⌻

  Keyboard: `K

  Dyadic operator: Outer Product, for a dyadic function F, x F⌻ y derives a dyadic function that returns an 
  array consisting of all combinations of the elements of the last axis of x with the elements of the leading 
  axis of y. 


  1 2 3 ,⌻ 1000 2000 3000
┌→─────────────────────────┐
↓┌→─────┐ ┌→─────┐ ┌→─────┐│
││1 1000│ │1 2000│ │1 3000││
│└──────┘ └──────┘ └──────┘│
│┌→─────┐ ┌→─────┐ ┌→─────┐│
││2 1000│ │2 2000│ │2 3000││
│└──────┘ └──────┘ └──────┘│
│┌→─────┐ ┌→─────┐ ┌→─────┐│
││3 1000│ │3 2000│ │3 3000││
│└──────┘ └──────┘ └──────┘│
└──────────────────────────┘
"
m ← m map:with "˝" "
  DOUBLE ACUTE ACCENT ˝

  Keyboard: `D

  Monadic operator: Functional Inverse, derives the functional inverse of the argument function. Generally, the 
  inverse of a function is a function that satisfies the following: F F˝ x = x. F˝ x can be seen as answering the 
  question: “what value z can I pass to F such that F z returns x?” Function needs to be one-to-one to have an 
  inverse.

  √˝2.0 ⍝ what has a square root of 2.0?
4.0


  Dyadic operator: Functional Inverse, derives the functional inverse of the argument function. The 
  inverse of a function is a function that satisfies the following: x F x F˝ y = y. The dyadic call 
  x F˝ y can be seen as answering the question: “what value z can I pass to x F z that will return y?”
  Function needs to be one-to-one to have an inverse.

  10-˝6 ⍝ what needs to be subtracted from 10 to get 6?
4
"
m ← m map:with "∘" "
  JOT ∘

  Keyboard: `j

  Dyadic operator: Compose, can be called either monadically or dyadically. 
  Called with functions f ang g and array Y, f∘g Y is evaluated as `Y f (g Y)`
  Called with functions f ang g and arrays X and Y, X (f∘g) Y is evaluated as X f (g Y). 


(+∘⍳)¨ 3 4 5                           ¯1 (+∘⍳)¨ 3 4 5 
┌→────────────────────────────┐      ┌→───────────────────────────────┐  
│┌→────┐ ┌→──────┐ ┌→────────┐│      │┌→─────┐ ┌→───────┐ ┌→─────────┐│
││3 4 5│ │4 5 6 7│ │5 6 7 8 9││      ││-1 0 1│ │-1 0 1 2│ │-1 0 1 2 3││
│└─────┘ └───────┘ └─────────┘│      │└──────┘ └────────┘ └──────────┘│
└─────────────────────────────┘      └────────────────────────────────┘
" 
m ← m map:with "⍛" "
  JOT UNDERBAR ⍛

  Keyboard: `F

  Dyadic operator: Inverse Compose, can be called either monadically or dyadically.
  Called with functions f ang g and array Y, f⍛g Y is evaluated as (f Y) g Y.
  Called with functions f ang g and arrays X and Y, X f⍛g Y is evaluated as (f X) g Y.


  {2|⍵}⍛/67 42 83  ⍝ simple filter idiom: F⍛/, in this case keep the odd elements
┌→────┐
│67 83│
└─────┘
"
m ← m map:with "⍤" "
  JOT DIAERESIS ⍤

  Keyboard: `J

  Dyadic operator: Rank, (f⍤a) applies its left operand function to cells of its arguments specified by its 
  right operand array. The right operand specifies the rank of subarrays to which the left operand function is 
  applied as follows: For left argument ⍺ and right argument ⍵,

   ⍤    c   ⍝ Rank-c cells of ⍵ (monadic) or both arguments (dyadic)
   ⍤  b c   ⍝ Rank-b cells of ⍺ and rank-c cells of ⍵ (dyadic)
   ⍤a b c   ⍝ Rank-a cells of ⍵ (monadic), b-cells of ⍺ and c-cells of ⍵ (dyadic)

  
  ⊢ m←3 3⍴⍳9 ⋄ v←10 20 30                 v +⍤1 ⊢m     ⍝ 1-cells + 1-cells
0 1 2                                   10 21 32
3 4 5                                   13 24 35
6 7 8                                   16 27 38
  +⌿ m ⍝ sum                              v +⍤0 1 ⊢m   ⍝ 0-cells + 1-cells
9 12 15                                 10 11 12
                                        23 24 25
  +⌿⍤1 ⊢m ⍝ +⌿ on 1-cells               36 37 38
3 12 21
"
m ← m map:with "⍥" "
  CIRCLE DIAERESIS ⍥

  Keyboard: `O

  Dyadic operator: Over, derives a function which, when called dyadically, calls the right function on both 
  arguments individually and then calls the left function on the results. In other words, this operator can 
  be thought of processing the arguments using A before acting on it using B.
  x A⍥B y is evaluated as (B x) A (B y)
  A⍥B y is evaluated as A B y


 -⍥⌊ 3.6       ⍝ Same as ∘ or ⍤ monadically 
¯3 
  5.1 -⍥⌊ 3.6  ⍝ Applies ⌊ to both arguments 
2 
  x←3 1 2
  y←4 6 5
  x +⍥(⌈/) y   ⍝ add the max of x and max of y
9
  ⍝ same as
  (⌈/x)+⌈/y
9
" 
m ← m map:with "⍢" "
  DEL DIAERESIS ⍢

  Keyboard: `G

  Dyadic operator: Under, takes two functions. When called as A⍢B x, the function B is first called on x, 
  and the return value is passed to A. The effect of B is then reversed.


  (10+)⍢(2↑) 3 3 ⍴ ⍳9  ⍝ takes 2 top rows, adds 10 to them and then puts back the bottom row
┌→───────┐
↓10 11 12│
│13 14 15│
│ 6  7  8│
└────────┘
"
m ← m map:with "⍫" "
  DEL TILDE ⍫

  Keyboard: `@

  Dyadic operator: Obverse, solves the problem f⍫g ↔ f except that (f⍫g)˝ ↔ g⍫f. 
  The result of f˝ is called the obverse of the function f. If f = g ∘ h, this obverse is h, and it is 
  otherwise an inverse of f. 


  ⍝ obverse of a monadic function            ⍝ obverse of a dyadic function
  foo ⇐ {100+⍵}                              foo ⇐ {5+⍺+4×⍵}
  bar ⇐ foo⍫{3+⍵}                            bar ⇐ foo⍫{(100×⍺)+(200+⍵)}
  (bar 10) (bar˝ 100)                        (10 bar 20) (10 bar˝ 20)
┌→──────┐                                  ┌→──────┐
│110 103│                                  │95 1220│
└───────┘                                  └───────┘  
"
m ← m map:with "∵" "
  BECAUSE ∵

  Keyboard: `S

  Monadic operator: Derive Bitwise, derives a version of the underlying function which performs its operation 
  on the individual bits of an integer. The following bitwise operations are implemented:

   +: xor   -: xor    ≠: xor    =: xnor    ×: and    ∧: and    ∨: or    ⍲: nand    ⍱: nor
   ≤: bitwise less than or equal           <: bitwise less than
   ≥: bitwise greater than or equal        >: bitwise greater than
   ⍴: number of bits required to store the integer value, excluding any sign bit
   ⍸: count bits      ~: not    ⌽: logical shift


  5 +∵ 3             5 =∵ 3               5 >∵ 3               
6                  -7                   4  
  5 ⌽∵ 3             5 ⍲∵ 3               5 -∵ 3
96                 -2                   6  
"
m ← m map:with "∥" "
  PARALLEL TO ∥  

  Keyboard: `M

  Monadic operator: Parallel, derives a new function that performs a parallel version of the function it is 
  applied to. The exact behaviour of the derived function depends on the specific underlying function.
  Currently, this operator can only be applied to ¨ (each). In this case, the result is computed split into 
  separate tasks that are executed in parallel. The number of tasks run in parallel is equal to the number of 
  CPU cores on the system.

  foo¨  1 2 3    ⍝ Evaluate foo on each value one by one
  foo¨∥ 1 2 3    ⍝ Evaluate foo for all the values in parallel
"
m ← m map:with "λ" "
  LAMBDA λ

  Keyboard: `V

  Monadic operator: Create Function Reference, λF creates an anonymous function where F is any function 
  as it appears in an expression. The return value is a primitive value which behaves just like any primitive. 
  It can be passed to other functions, and be members of arrays. When creating a function reference, the function
  captures any lexical bindings references from within the function. These bindings remain valid even after the 
  scope is exited. To call a function from a function reference, use the apply symbol: ⍞. 


  m1 ← λ-                     ⍝ monadic projection     
  m2 ← λ(0-)                  ⍝ monadic projection
  m3 ← λ{-⍵}                  ⍝ explicit monad
  arrayOfMonads ← m1 m2 m3    ⍝ monads                       
  4 {⍞⍵ ⍺}¨ arrayOfMonads
┌→───────┐
│-4 -4 -4│
└────────┘
"
m ← m map:with "⍠" "
  COLON QUAD ⍠

  Dyadic operator: Call method. Kap objects that have been created with map and have field kap:methods 
  are called with ⍠. Left argument is object name, right argument is method name and argument. 

  Object format: 
  objectname ← 'fieldname fieldvalue ... 'kap:methods (map:with 'methodname λ{ methodbody })
  
  To call the method: objectname⍠methodname methodargument


  a ← map:with 'value 10 `
          'kap:methods (map 'valuePlusN λ{ ⍺.value + ⍵ })
┌Map: 2─────────────────────────────────────┐
│default:value                            10│
│  kap:methods ┌Map: 1─────────────────────┐│
│              │default:valuePlusN function││
│              └───────────────────────────┘│
└───────────────────────────────────────────┘
  a ← a map:with 'value 20   ⍝ field values can be updated with map:with
  a⍠valuePlusN 100         ⍝ calling method
120
"
m ← m map:with "⍞" "
  QUOTE QUAD ⍞

  Keyboard: `{

  Monadic operator: Apply, call a function given its function reference. It can take any of the following forms:
  ⍞variable calls the function reference stored in variable variable.
  ⍞(expression) expresion is evaluated to return a function reference which is subsequently called.


  foo ← λ{1+⍵}            { ⍞⍵/ 10 11 12 13 }¨ λ× λ+   ⍝ (10×11×12×13, 10+11+12+13)
  bar ← λ{⍵}            ┌→───────┐
  ⍞(⍞bar foo) 7         │17160 46│
8                       └────────┘
"
m ← m map:with "⍎" "
  HYDRANT ⍎

  Keyboard: `;

  Monadic function: Parse Number, parses string as a number. Argument must be only numbers and nothing else.

 
  ⍎\"123\"       ⍎\"123 and some other stuff thats not a number\" 
123          Error at: 1:1: ⍎: Value cannot be parsed as a number: '123 and some other stuff thats not a number'
"
m ← m map:with "⍕" "
  THORN ⍕

  Keyboard: `'

  Monadic function: Format, formats the right argument into a simple character array.
 
  4 5 6     ⍝ numeric vector 
4 5 6 
  ⍕4 5 6    ⍝ equivalent character vector 
\"456\"
 

  Dyadic function: Format With Pattern, formats a string given as left argument with the data given as
  right argument. 
 
  \"a$sfoo$sbar\" ⍕ 2 2 2 ⍴ ⍳8           \"a$sfoo$sbar\" ⍕ 3 2 ⍴ ⍳6
┌→──────────────────┐                  ┌→────────────────────────────┐
↓a0foo1bar a2foo3bar│                  │a0foo1bar a2foo3bar a4foo5bar│
│a4foo5bar a6foo7bar│                  └─────────────────────────────┘ 
└───────────────────┘
"
m ← m map:with "⍰" "
  QUAD QUESTION ⍰

  Keyboard: `A

  Monadic operator: Conditional Null Call, derives a function which, when called, checks if the right argument is 
  null. If it is, returns null. Otherwise calls the original function with the arguments as passed to the derived 
  function. This is useful when looking up values in hashmaps.


  1 2 +⍰ 100 200        1 2 +⍰ null
┌→──────┐             null
│101 202│
└───────┘
"
m ← m map:with "«" "
  LEFT DOUBLE ANGLE QUOTE «

  Keyboard: `B

  Left Fork: When you use forks, you need to use double angle quotes. 
  Let f, g, h be functions and X, Y arrays. A fork is a 3-function 
  composition of the following form:

  f«h»g Y is evaluated as (f Y) h (g Y)

  X f«h»g Y is evaluated as (X f Y) h (X g Y)


  x ← 3 4 ⍴ 3 1 4 1 5 9 2 7 1 8 2 8
┌→──────┐
↓3 1 4 1│                  (+⌿«÷»≢) x    ⍝ mean: summation f, array length g, division h
│5 9 2 7│                ┌→───────────┐  
│1 8 2 8│                │3 6 8/3 16/3│   
└───────┘                └────────────┘   
"
m ← m map:with "»" "
  RIGHT DOUBLE ANGLE QUOTE »

  Keyboard: `B

  Right Fork: When you use forks, you need to use double angle quotes.
  Let f, g, h be functions and X, Y arrays. A fork is a 3-function 
  composition of the following form:

  f«h»g Y is evaluated as (f Y) h (g Y)

  X f«h»g Y is evaluated as (X f Y) h (X g Y)


  x ← 3 4 ⍴ 3 1 4 1 5 9 2 7 1 8 2 8
┌→──────┐
↓3 1 4 1│                  (+⌿«÷»≢) x    ⍝ mean: summation f, column length g, division h
│5 9 2 7│                ┌→───────────┐  
│1 8 2 8│                │3 6 8/3 16/3│   
└───────┘                └────────────┘   
"
m ← m map:with "⋄" "
  DIAMOND ⋄

  Keyboard: ```

  Syntax: Statement Separator, allows placing multiple statements on a single line. Statements are evaluated 
  sequentially from left to right. Each separate statement will be read as if on its own line. 
 
  A←4 ⋄ A←A×3 ⋄ A÷2 
6 
"
m ← m map:with "⍝" "
  LAMP ⍝

  Keyboard: `,

  Syntax: Comment, ⍝ indicates the start of a comment. Everything to the right of ⍝ until the next newline 
  will be ignored.


  2+3   ⍝ this is a comment and will be ignored 
5 
"
m ← m map:with "→" "
  RIGHT ARROW →

  Keyboard: `]

  Monadic function: Return, returns value from the innermost function. 


  ⍝ return 10, nothing will be printed
  ∇ foo {
    → 10
    io:println \"This line will never be called\"
  }
  foo 1
10 


  Dyadic function: Conditional return, will return if the left argument is true. This is useful for 
  conditional early returns.

  Given the following conditional return:

  if (a) {
    → b
  }

  This could more easily be written as such:

  a → b
"
m ← m map:with "⍵" "
  OMEGA ⍵

  Keyboard: `w

  Syntax: Right argument of a function block
 

  2 {⍵+1} 5 
6 
"
m ← m map:with "⍺" "
  ALPHA ⍺
 
  Keyboard: `a

  Syntax: Left argument of a function block
 

  2 {⍺+1} 5 
3 
" 
m ← m map:with "∇" "
  DEL ∇

  Keyboard: `g

  Syntax: Define a global function or operator. 

  The general form is:

  ∇ header {
    body
  }
  
  The last evaluated form in body is returned from the function.
  
  The header has the following possible forms:
  
      name — Declare a function named name. In body, the left argument is accessed using ⍺ and the 
      right argument using ⍵.
  
      name x — The right argument is accessed using the name x. The left argument is not accessible.
  
      x name y — The left argument is accessed using the name x, and the right argument has the name y.
  
      (a;b) name (d;e) — The left and right arguments are assumed to be n-tuples and are destructured 
      prior to evaluating the body.
  
      (a name) x — Monadic operator deriving a monadic function.
  
      x (a name b) y — Dyadic operator deriving a dyadic function.
  
  When declaring an operator, the function arguments are passed as function objects, and needs to be 
  applied using the function application operation: ⍞.
  
  To declare a monadic function that returns the argument + 1:
  
  ∇ foo x {
    x+1
  }
  
  To declare an operator that adds 100 to the result of evaluating the function after adding 1 to the argument:
  
  ∇ (a foo) x {
    result ← ⍞a 1+x
    100 + result
  }
"
m ← m map:with "⍓" "
  QUAD UP CARET ⍓

  Keyboard: `t

  Syntax: Recursion, calls the function itself. This feature is currently not supported, as Kap does not yet do 
  proper tail call optimization. It is possible to call a function recursively using its own name though.
"
m ← m map:with "¯" "
  HIGH MINUS ¯

  Keyboard: `2

  Syntax: Qualifier for negative number 
 

  1 + ¯1 0 1 ¯3 
0 1 2 ¯2 
 
  3e¯2 
0.03 
"
m ← m map:with "⍬" "
  ZILDE ⍬

  Keyboard: `}

  Niladic: Empty Array 
 
  ⍬≡⍳0 
1 
  ⍬≡0⍴0 
1 
  ⍬≡0 0⍴0 
0 
  ⍬≡\"\"
1  
"
m ← m map:with "∆" "
  INCREMENT ∆ 

  Keyboard: `h

  Syntax: Identifier, feature is currently not in use. 

"
m ← m map:with "⍙" "
  INCREMENT UNDERBAR ⍙ 

  Keyboard: `H

  Syntax: Identifier, feature is currently not in use. 

"
m ← m map:with "%" "
  PERCENT %

  Dyadic function: Case, accepts an array of indices and a list of arrays, each with the same shape as the 
  index array, and for each cell in the index, pick a corresponding value in one of the subarrays.  


  0 1 1 2 % \"abcd\" \"1234\" \"defg\"
\"a23g\"
"
m ← m map:with "@" "
  AT @

  Syntax: Character type. A character is a single Unicode codepoint. The following forms are allowed:

    @a   Any character is allowed, except backlash
    @\\LATIN_CAPTIAL_LETTER_B   Unicode name, spaces are replaced with underscore
    @\\u0397   Hex codepoint
    @\\n   Newline (codepoint U+000A)
    @\\r   CR (codepoint U+000D)
    @\\e   Esc
    @\\s   Space
    @\\t   Tab
    @\\\\   Backslash
    @\\0   Nul character

  
  unicode:toNames @⎕
\"APL FUNCTIONAL SYMBOL QUAD\"
  @\\APL_FUNCTIONAL_SYMBOL_QUAD
@\\u2395
  typeof @\\u2395
kap:char
  @\\u2395, \" \"
\"⎕ \"
  typeof (@\\u2395, \" \")
kap:array  
"
m ← m map:with "kap" "

  kap namespace contains most of the Kap language elements and primitives. Type ]man primitives to see the
  list of primitives. 

  In addition, the following functions reside in the kap namespace (just do ]man <function> without the kap:
  namespace):

  close   Close a stateful object (stream, database)         sysparam   Look up or set system metadata
  cmp   Compare arrays                                       throw   Throw an exception
  comp   Force evaluation of lazy values                     toBoolean   Convert variable to Boolean value
  fromList   Convert N-tuple/list to array                   toList    Convert array to N-tuple
  isLocallyBound    Check function variables in scope        toRational   Convert a value to rational number
  labels   Set and get array axis labels                     typeof   Get object type
  map:with   Create or update a map                          vectorEncode   the same as ⊤ for vector values
  map:get   Get values from maps
  map:keys   Get map keys
  map:remove   Remove key-value pairs from maps
  map:size   Get the number of key-value pairs
  map:entries   Get a map as an array
"
m ← m map:with "QR" "
  QR (matrix)

  Matrix QR decomposition. The only argument is the square matrix you want to decompose. 


  kap:QR 3 3⍴12 ¯51 4 6 167 ¯68 ¯4 24 ¯41  ⍝ example from https://en.wikipedia.org/wiki/QR_decomposition#Example
┌→───────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│┌→───────────────────────────────────────────────────────────┐ ┌→──────────────────────────────────────────┐│
│↓ 0.8571428571428571 -0.3942857142857143 -0.33142857142857146│ ↓14.0 20.999999999999996 -14.000000000000002││
││0.42857142857142855  0.9028571428571428  0.03428571428571396│ │   0              175.0               -70.0││
││-0.2857142857142857 0.17142857142857143  -0.9428571428571428│ │   0                  0                35.0││
│└────────────────────────────────────────────────────────────┘ └───────────────────────────────────────────┘│
└────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
"
m ← m map:with "Rinv" "
  Rinv (matrix)

  Rinv is a helper function used to compute ⌹. 

"
m ← m map:with "close" "
  close (object)

  Close a stateful object (stream, database etc.). Streams and database connections must be closed.


  conn ← sql:connect \"jdbc:sqlite:/path/to/database\"
Connection(url=jdbc:sqlite:/path/to/database)
  result ← conn sql:query myquery
  close conn
"
m ← m map:with "cmp" "
  (arrayA) cmp (arrayB)

  Dyadic function: Compare arrays.  
  Returns -1 if arrayA is less than arrayB, 0 if they are equal or 1 if arrayA is greater than arrayB.


  (3 3⍴⍳6) cmp (3 3⍴⍳9)
-1
  (2 3⍴⍳9) cmp (3 3⍴⍳9)
-1
  (3 3⍴⍳9) cmp (3 3⍴⍳9)
0  
"
m ← m map:with "comp" "
  comp (array)

  Force evaluation of lazy values. Collapses a possibly lazy array and evaluates all values. The return values 
  are guaranteed to be a self-contained array with no references held to any other objects. Reading from this 
  array will not cause concurrency issues.


  time:runtime { +/ comp 100000000 ⍴ 1 2 }
Total time: 0.6

150000000
"
m ← m map:with "fromList" "
  fromList (list)

  Convert N-tuple/list to array. 


  fromList (23 ; \"skidoo\" ; :asdf)
┌→────────────────┐
│23  skidoo  :asdf│
└─────────────────┘
"
m ← m map:with "isLocallyBound" "
  isLocallyBound (symbol)

  isLocallyBound checks if a symbol name is bound to a value. This is useful if you want to check whether a 
  function is being called monadically or dyadically. Symbol needs to have a quote in front of its name.


  ∇ (A) calling (B) {
    if (isLocallyBound('A)) {
      \"calling dyadically\"
    } else {
      \"calling monadically\"
    }
  }
⍬    
  calling :a
\"calling monadically\"
  :b calling :a
\"calling dyadically\"
"
m ← m map:with "norm" "
  norm (array)

  Computes the 2-norm of a vector. This is the same as { √⍵+∙×⍵ }


  kap:norm 1 2 3 4
5.477225575051661
  { √⍵+∙×⍵ } 1 2 3 4
5.477225575051661
"
m ← m map:with "scalarEncode" "
  (base) scalarEncode (decimalnum)

  Dyadic function: Encode a scalar decimal number in given base. This is the same as ⊤ with scalar arguments.


  3 kap:scalarEncode 11
┌→────┐
│1 0 2│
└─────┘
"
m ← m map:with "sysparam" "
  sysparam (symbol)

  Look up system metadata. 


  sysparam 'kap:platform
kap:jvm
"
m ← m map:with "throw" "
  throw (errorstring)

  Throws an exception. This exception can be caught with catch. 


  func ⇐ { if (⍵≡0) { throw \"Whoops! Cannot divide by zero.\" } else { 1÷⍵ } }
⍬
  func 3
1/3
  func 0
Error at: 1:21: throw: Whoops! Cannot divide by zero.
"
m ← m map:with "toBoolean" "
  toBoolean (value)

  Convert variable to scalar Boolean value. Generally gives the value 1 (true) to objects, unless the object 
  value is 0.


  toBoolean¨ (2 2⍴1 0 0 1)             toBoolean 2 2⍴1 0 0 1
┌→──┐                                1  
↓1 0│                                  toBoolean (2 2⍴1 0 0 1)
│0 1│                                1
└───┘                                  toBoolean (2 2⍴0 0 0 0)
toBoolean¨ ,(2 2⍴1 0 0 1)            1
┌→──────┐                              toBoolean 0 0 0 0
│1 0 0 1│                            1
└───────┘                              toBoolean (0 0 0 0)
                                     1  
"
m ← m map:with "toList" "
  toList (array)

  Convert array to list. Argument must be 1-dimensional.


  toList 0
╔═╗
║0║
╚═╝
  toList 0 0 0 0
╔═╤═╤═╤═╗
║0│0│0│0║
╚═╧═╧═╧═╝ 
"
m ← m map:with "toRational" "
  toRational (decimalnum)

  Convert decimal numbers to rationals.


  toRational 0.123
553942754166571/4503599627370496

  toRational 0.125 0.5
┌→──────┐
│1/8 1/2│
└───────┘  
" 
m ← m map:with "typeof" "
  typeof (object)

  Get object type.


  type⇐{ t←typeof ⍵ ⋄ if ('kap:integer≡t) { ⊣ io:println t, \"! we love numbers\" } else { ⊣ io:println t, \"! no number :(\" } }
  type 1
kap:integer! we love numbers
  
  type \"a\"
kap:array! no number :(
  
  type 1 \"a\"
kap:array! no number :(
"
m ← m map:with "vectorEncode" "
  (base) vectorEncode (decimalnum)

  This is the same as ⊤. See the help for ⊤

"
m ← m map:with "regex" "

  regex is the namespace for regular expression functions. Regex is a sequence of characters that specifies a 
  match pattern in text. Usually such patterns are used by string-searching algorithms for \"find\" or \"find and 
  replace\" operations on strings, or for input validation. 
  
  regex:compile   Create regex
  regex:find   Find the first regex match in a string
  regex:findall   Find all matches in a string
  regex:finderror   Find matches in string or raise error
  regex:match   Match string against regex
  regex:replace   Replace by regex
  regex:split   Split by regex
"
m ← m map:with "regex:compile" "
  regex:compile (string)

  Compile a regular expression, the input must to be given as string.


  email←regex:compile \"[a-zA-Z0-9]{1,64}\@[a-zA-Z0-9]{1,64}.[a-z]{2,}$\" 
regex-matcher
"
m ← m map:with "regex:find" "
  (regex) regex:find (string)

  Looks for the first matching occurrence in the input and returns it. Returns empty array if no matches.


  \"BROWN\" regex:find \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\"
┌→──────┐
│\"BROWN\"│
└───────┘

  \"^zx:(foo)?:x$\" regex:find \"zx::x\"  ⍝ the whole string matches, and so does the optional foo
┌→─────────────────┐                      ⍝ but zero length string matches are :undefined
│\"zx::x\" :undefined│
└──────────────────┘
  \"^zx:([a-z]+):x$\" regex:find \"zx:test:x\"  ⍝ the whole string matches and so does \"test\"
┌→─────────────────┐
│\"zx:test:x\" \"test\"│
└──────────────────┘
"
m ← m map:with "regex:findall" "
  (regex) regex:findall (string)

  Finds all matching occurrences in the input. Returns empty array if no matches.


  str←\"The example above uses a train with five functions: an odd number. Trains with an odd length are always 
composed of length-3 trains, and they themselves are composed the same way as subject expressions: an odd-length
train can be placed in the last position of another train without parentheses, but it needs parentheses to go 
in any other position.\"

  \"[T|t]?rain.\" regex:findall str
┌→─────────────────────────────────────────────────────┐
│┌→───────┐ ┌→───────┐ ┌→───────┐ ┌→───────┐ ┌→───────┐│
││\"train \"│ │\"Trains\"│ │\"trains\"│ │\"train \"│ │\"train \"││
│└────────┘ └────────┘ └────────┘ └────────┘ └────────┘│
└──────────────────────────────────────────────────────┘  
"
m ← m map:with "regex:finderror" "
  (regex) regex:finderror (string)

  Looks for the first matching occurrence in the input and returns it. Throws an error if no matches.
  If there will be no matches, it is better to use find than finderror. finderror exists for the cases 
  where it is already known finding going to match.


  \"BROWN\" regex:finderror \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\"
┌→──────┐
│\"BROWN\"│
└───────┘

  \"^xp:(foo)?:x$\" regex:finderror \"zx::x\"  ⍝ xp does not match
Error at ../array/standard-lib/regex.kap: 6:5: throw: No match

  \"^xp:([a-z]+):x$\" regex:finderror \"zx:test:x\"  ⍝ xp does not match
Error at ../array/standard-lib/regex.kap: 6:5: throw: No match
"
m ← m map:with "regex:match" "
  (regex) regex:match (string)

  Match string against a regular expression. Left argument is regex, right argument is string.
  Regex can be given as an input string or a compiled regular expression created with regex:compile. 
  Pattern matching is the act of checking a given sequence of tokens for the presence of the 
  constituents of some pattern. The regex string needs to be all in one line.


  \"BROWN\" regex:match \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\"
1
  email←regex:compile \"[a-zA-Z0-9]{1,64}\@[a-zA-Z0-9]{1,64}.[a-z]{2,}$\" 
  str←\"Delivered-To: info@dhsdevelopments.com\"
  email regex:match str
1
"
m ← m map:with "regex:replace" "
  (regex) regex:replace (inputstring ; replacementstring)

  Replace matching occurrences in inputstring with replacementstring. 


  \"x[0-9]*\" regex:replace (\"foox11barx8bar\";\"|\") ⍝ replaces occurrences of one or more numbers with |
\"foo|bar|bar\"

  email←regex:compile \"[a-zA-Z0-9]{1,64}\@[a-zA-Z0-9]{1,64}.[a-z]{2,}$\" 
  str←\"Delivered-To: info@dhsdevelopments.com\"
  email regex:replace (str ; \"<emailcensored>\")
\"Delivered-To: <emailcensored>\"
"
m ← m map:with "regex:split" "
  (regex) regex:split (string)

  Split string into an array of substrings at the positions defined by regular expression match.


  \",+\" regex:split \"foo,bar,,test,cba,,,,\"
┌→─────────────────────────┐
│\"foo\" \"bar\" \"test\" \"cba\" ⍬│
└──────────────────────────┘  

  email←regex:compile \"[@ ]\"
  str←\"Send-To: info@dhsdevelopments.com\"
  email regex:split str
┌→──────────────────────────────────────┐
│\"Send-To:\" \"info\" \"dhsdevelopments.com\"│
└───────────────────────────────────────┘
"
m ← m map:with "json" "

  json is the namespace for functions dealing with JSON (JavaScript Object Notation). JSON an open standard file 
  format and data interchange format that uses human-readable text to store and transmit data objects consisting 
  of name–value pairs and arrays (or other serializable values). It is a commonly used data format with diverse 
  uses in electronic data interchange, including that of web applications with servers. 
  
  json:read   Parse JSON from file
  json:readString   Parse JSON from string
  json:writeString   Write Kap objects as JSON
"
m ← m map:with "json:read" "
  json:read (filepath)

  Reads .json file from given filepath. Returns a map.

  json:read \"test-data/json-test.json\" 
┌Map: 7───────────────────────────────────┐
│ booleanValue                           1│
│booleanValue2                           0│
│          foo                         1.0│
│   nullValue0                        null│
│ recursiveMap                   ┌Map: 2─┐│
│                                │ a  1.0││
│                                │ b  2.0││
│                                └───────┘│
│    someArray ┌→────────────────────────┐│
│              │1.0 2.0 3.0 4.0 ┌→──────┐││
│              │                │5.0 6.0│││
│              │                └───────┘││
│              └─────────────────────────┘│
│   someString                    foo test│
└─────────────────────────────────────────┘ 
"
m ← m map:with "json:readString" "
  json:readString (string)

  Reads JSON data given as string. Returns a map.


  json:readString \"{\\\"a\\\":10,\\\"b\\\":\\\"c\\\"}\"
┌Map: 2┐
│a 10.0│
│b   c │
└──────┘
"
m ← m map:with "json:writeString" "
  json:writeString (object)

  Writes a Kap memory object as JSON string. Object can be a nested array or a map.


  json:writeString (\"first\" (1 2 3)) (\"second\" (4 5 6))
\"[\"first\",[1,2,3],\"second\",[4,5,6]]\"

  json:writeString⟦map:with \"a\" (10 20 30) \"b\" 234 \"somestuff\" (300 (4 5 6))⟧
\"{\"somestuff\":[300,[4,5,6]],\"b\":234,\"a\":[10,20,30]}\"
"
m ← m map:with "unicode" "
 
  unicode is the namespace for unicode helper functions. The Unicode Standard is a character encoding standard 
  maintained by the Unicode Consortium designed to support the use of text in all of the world's writing systems 
  that can be digitized. 

  unicode:dec   Decode a byte array to a string
  unicode:enc   Encode a string to a byte array
  unicode:fromCodepoints   Convert codepoints to characters
  unicode:toCodepoints   Convert characters to codepoints
  unicode:toGraphemes   Split a string into graphemes
  unicode:toLower   Convert a string to lower case
  unicode:toNames   Return Unicode names
  unicode:toUpper   Convert a string to upper case
"
m ← m map:with "unicode:dec" "
  (encoding) unicode:dec (bytearray)

  Monadic: Decode the given array as UTF-8 and return the resulting string.


  unicode:dec 236 156 132 97 98 99 195 165 226 141 184 226 140 187 117 68 56 51 68 117 68 69 51 65
\"위abcå⍸⌻uD83DuDE3A\" 


  Dyadic: Decode a byte array with a specific encoding. Left argument is encoding, right argument is bytearray.
  Currently the following encodings are supported:

    :UTF8 — UTF-8
    :UTF16 — UTF-16 with a BOM
    :UTF16LE — UTF-16 little endian without a BOM
    :UTF16BE — UTF-16 big engine without a BOM
    :UTF32 — UTF-32. Currently, the endianness and BOM behaviour are different depending on platform. This will 
    change in a later version.


  :UTF16 unicode:dec 254 255 199 4 0 97 0 98 0 99 0 229 35 120 35 59 0 117 0 68 0 56 0 51 0 68 0 117 0 68
\"위abcå⍸⌻uD83DuD\"
"
m ← m map:with "unicode:enc" "
  (encoding) unicode:enc (string)

  Monadic: Encode a string as UTF-8. Accepts a string, and returns a byte array containing the UTF-8 
  representation of the string.


  unicode:enc \"위abcå⍸⌻\uD83D\uDE3A\"
┌→───────────────────────────────────────────────────────────────────────────────────┐
│236 156 132 97 98 99 195 165 226 141 184 226 140 187 117 68 56 51 68 117 68 69 51 65│
└────────────────────────────────────────────────────────────────────────────────────┘


  Dyadic: Encode a string with a specific encoding. Left argument is encoding parameter, right argument string.
  Currently the following encodings are supported:

    :UTF8 — UTF-8
    :UTF16 — UTF-16 with a BOM
    :UTF16LE — UTF-16 little endian without a BOM
    :UTF16BE — UTF-16 big engine without a BOM
    :UTF32 — UTF-32. Currently, the endianness and BOM behaviour are different depending on platform. This will 
    change in a later version.

  
  :UTF16 unicode:enc \"위abcå⍸⌻\uD83D\uDE3A\"
┌→──────────────────────────────────────────────────────────────────────────────────────────────────┐
│254 255 199 4 0 97 0 98 0 99 0 229 35 120 35 59 0 117 0 68 0 56 0 51 0 68 0 117 0 68 0 69 0 51 0 65│
└───────────────────────────────────────────────────────────────────────────────────────────────────┘
"
m ← m map:with "unicode:fromCodepoints" "
  unicode:fromCodepoints (codepoints)

  Convert codepoints to characters. Frequently seen U+<number> is a hexadecimal codepoint that you can give to
  the function directly. For example, the two APL characters, LAMP ⍝ and QUOTE QUAD ⍞ have codepoint representations
  U+235D and U+235E respectively (with a space U+0020 in between them). 


  unicode:fromCodepoints 0x235D 0x20 0x235E
\"⍝ ⍞\"
"
m ← m map:with "unicode:toCodepoints" "
  unicode:toCodepoints (utf8string)

  Convert characters to codepoints. The given input is a regular string in UTF8 encoding. 


  unicode:toCodepoints \"⍝ ⍞\"
┌→───────────┐
│9053 32 9054│
└────────────┘
"
m ← m map:with "unicode:toGraphemes" "
  unicode:toGraphemes (utf8string)

  Split a UTF-8 string into graphemes. 


  unicide:stringToGraphemes \"諸惡莫作，眾善奉行。\"
┌→────────────────────────────────────────────┐
↓\"諸\" \"惡\" \"莫\" \"作\" \"，\" \"眾\" \"善\" \"奉\" \"行\" \"。\"│
└─────────────────────────────────────────────┘  
"
m ← m map:with "unicode:toLower" "
  unicode:toLower (utf8string)

  Convert a string to lower case.


  unicode:toLower \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\"
\"the quick brown fox jumps over the lazy dog\"
"
m ← m map:with "unicode:toNames" "
  unicode:toNames (utf8string)

  Return Unicode names of each character. Due to the rather large number of various characters in Unicode, 
  all characters have names in addition to codepoint. To see the character names, you may use unicode:toNames.

  
  unicode:toNames \"⍝ ⍞\"
┌→─────────────────────────────────────────────────────────────────────────────┐
│\"APL FUNCTIONAL SYMBOL UP SHOE JOT\" \"SPACE\" \"APL FUNCTIONAL SYMBOL QUOTE QUAD\"│
└──────────────────────────────────────────────────────────────────────────────┘
"
m ← m map:with "unicode:toUpper" "
  unicode:toUpper (utf8string)

  Convert a string to upper case.


  unicode:toUpper \"the quick brown fox jumps over the lazy dog\"
\"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\"
"
m ← m map:with "io" "

  io is the namespace for input/output functions. These deal with reading, writing and printing data.

  io:encodeUtf8   see help for unicode:enc, it is the same function
  io:encodeUtf8Char   see help for unicode:toCodepoints, it is the same function
  io:fromHex   converts hexadecimal string into decimal
  io:fromHtmlTable   creates an array out of HTML table string 
  io:load   loads a Kap script from a file and executes it
  io:print   Print a value
  io:println   Print string and add a newline
  io:read   Read file
  io:readCsv   Read CSV file
  io:readFile  Read file
  io:readLine  Read user input from standard input 
  io:readdir   Read contents of a directory
  io:toHex   converts decimal number into hexadecimal string
  io:toHtml   create HTML elements out of Kap objects
  io:write   Write into file 
  io:writeCsv   Write a CSV file
"
m ← m map:with "io:fromHex" "
  io:fromHex (string)

  Convert a string containing hexadecimal number into decimal integer.


  io:fromHex \"ABBA\"
43962
"
m ← m map:with "io:fromHtmlTable" "
  io:fromHtmlTable (string)

  Creates a Kap array out of a string containing HTML table. 


  io:fromHtmlTable \"<html><body>Foo<table><thead><th>Foo</th><th>Bar</th></thead><tbody>
  <tr><td>1</td><td>10</td></tr><tr><td>abctest</td><td>123foo</td></tr><tr><td>2</td>
  <td>3</td></tr></tbody></table></body></html>\"
┌─────────┬───┐
│      Foo│Bar│
├→────────┴───┤
↓        1  10│
│  abctest 123│
│        2   3│
└─────────────┘
"
m ← m map:with "io:load" "
  io:load (filepath)

  Loads a Kap script from a file and executes it. Given argument must be a .kap script file.
  Any other types of files should be opened with io:read. 


  Given file test-data/test-source.kap with the following contents:
namespace(\"foo\")
∇ bar (x) { x + 100 }
10

  io:load \"test-data/test-source.kap\"
10
  foo:bar 1
101  
"
m ← m map:with "io:print" "
  io:print (input)

  Print to standard output. 


  ⊣ io:print \"hello from Kap\"
hello from Kap

  datetime ← \"T\" regex:split time:format time:toTimestamp time:timeMillis 0
  ⊣ io:print \"the time is \" (\"\\.\" regex:split ↑datetime[1])[0] 
the time is 11:07:17

  ⊣ {io:print ⍵}¨⍳9
012345678
"
m ← m map:with "io:println" "
  io:println (input)

  Print to standard output. A newline will be added after every printed value.


  ⊣ io:println \"hello from Kap\"
hello from Kap

  ⊣ {io:println ⍵}¨⍳9
0
1
2
3
4
5
6
7
8
"
m ← m map:with "io:read" "
  io:read (filepath)

  Read the contents of the argument filepath. Returns the lines in the file as an array of strings.


  io:read \"test-data/test-source.kap\"  
┌→──────────────────────────────────────────────────────────┐
│\"namespace(\"foo\")\" ⍬ \"∇ bar (x) {\" \"    x + 100\" \"}\" ⍬ \"10\"│
└───────────────────────────────────────────────────────────┘
"
m ← m map:with "io:readCsv" "
  io:readCsv (csvfilepath)

  Create Kap array out of CSV file. This function accepts either one or two arguments. The first argument is 
  always a string, indicating a file to be read. The second argument, if provided, is a list of keyword 
  arguments and a boolean value for it. The following keywords are available:

    :separator — The character used to separate fields. Default is ,.
    :quoteChar — The character used for quoting values. Default is \".
    :trim — A boolean value indicating if unquoted values should be trimmed. If true, whitespace before 
    and after the value is removed. The default is 1.
    :parseNumbers — If true, the parser will convert values that looks like numbers into numeric values, 
    rather than strings. If a value cannot be parsed as number, the string value will be used. The default is 1.


  io:readCsv⟦\"/home/user/full/path/to/array/test-data/penguins.csv\" ; :parseNumbers 1⟧
┌→─────────────────────────────────────────────────────────────────────────────────────────────────────────┐
↓ species      island     bill_length_mm    bill_depth_mm flipper_length_mm   body_mass_g      sex     year│
│  Adelie   Torgersen               39.1             18.7               181          3750     male     2007│
│  Adelie   Torgersen               39.5             17.4               186          3800   female     2007│
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 
│ Chinstrap     Dream               49.6             18.2               193          3775     male     2009│
│ Chinstrap     Dream               50.8               19               210          4100     male     2009│
│ Chinstrap     Dream               50.2             18.7               198          3775   female     2009│
└──────────────────────────────────────────────────────────────────────────────────────────────────────────┘
"
m ← m map:with "io:readFile" "
  io:readFile (filepath)

  Reads a file using the JVM i/o functions. 


  io:readFile \"/home/user/full/path/to/array/test-data/multi.txt\"
\"foo      
bar       
test      
abcdef    
testtest  
  testline
aa        
ab        
ac        
ad        
\"         
"
m ← m map:with "io:readLine" "
  io:readLine (prompt)

  Asks for input from the user. The argument prompt is printed to standard output. Then the function reads
  the line the user inputs to standard input and returns it. Prompt can be an empty string \"\" but it cannot
  be left out. 


  firstname←io:readLine \"Please give your first name: \"
\"Kap\"
  lastname←io:readLine \"Please give your last name: \"
\"User\"
  ⊣ io:println \"Hello, \" firstname \" \" lastname
Hello, Kap User
"
m ← m map:with "io:readdir" "
  (format) io:readdir (pathstring)

  Read contents of a directory. Right argument is the path to be read as a string. Returns an array.
  When called monadically, this function assumes the left argument is an empty array.


  io:readdir \"/home/user/full/path/to/array/test-data/readdir-test\"
┌→──────────┐
↓    \"a.txt\"│
│\"file2.txt\"│
└───────────┘

  When called dyadically, the format argument signifies which data is displayed in the output array.
  Format is a list of specifiers indicating what information should be included. Currently, the following 
  formats are supported:

    :size — the size of the file, or 0 if the entry is a directory
    :type — the type of the entry, possible results are: :file, :directory or :undefined


  :size io:readdir \"/home/user/full/path/to/array/test-data/readdir-test\"
┌→─────────────┐
↓    \"a.txt\" 12│
│\"file2.txt\" 27│
└──────────────┘
"
m ← m map:with "io:toHex" "
  io:toHex (decimalnum)

  Converts a decimal integer to hexadecimal number. The returned value is a string.

  io:toHex 43962
\"ABBA\"
"
m ← m map:with "io:toHtml" "
  io:toHtml (argument)

  Create HTML elements out of Kap objects. If the argument is a simple non-nested array, the output will be a HTML <table>.
  If the argument is a map, the output will be preformatted.


  jsonmap←json:read \"test-data/json-test.json\"        inputarray
  ⊣io:println io:toHtml jsonmap                       ┌→───────────────────────────────────────────────────┐
<pre>map(size=7)                                      ↓  bill_length_mm   bill_depth_mm   flipper_length_mm│
  ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓       │            39.1            18.7                 181│
  ┃     someArray  ┏━━━━━━━━━━━━━━━━━━━━━━━━━┓┃       │            39.5            17.4                 186│
  ┃                ┃1.0 2.0 3.0 4.0 ┏━━━━━━━┓┃┃       │            40.3              18                 195│              
  ┃                ┃                ┃5.0 6.0┃┃┃       │             NA              NA                  NA │              
  ┃                ┃                ┗━━━━━━━┛┃┃       │            36.7            19.3                 193│                   
  ┃                ┗━━━━━━━━━━━━━━━━━━━━━━━━━┛┃       └────────────────────────────────────────────────────┘
  ┃    nullValue0                         null┃
  ┃    someString                     foo test┃         ⊣io:println io:toHtml inputarray
  ┃  recursiveMap                  map(size=2)┃       <table style=\"border: 1px solid; border-collapse: collapse;\"><tbody><tr>...  
  ┃                                  ┏━━━━━━━┓┃       
  ┃                                  ┃ b  2.0┃┃
  ┃                                  ┃ a  1.0┃┃
  ┃                                  ┗━━━━━━━┛┃
  ┃                                           ┃
  ┃  booleanValue                            1┃
  ┃ booleanValue2                            0┃
  ┃           foo                          1.0┃
  ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
</pre> 
"
m ← m map:with "io:write" "
  (filepath) io:write (string)  

  Write string into file. The left argument is the path to file and its name, right argument is the content to be 
  written. If the content to be written is not a string, you will need to use the stream functions found in the 
  io2 namespace.


  \"trains.txt\" io:write \"The example above uses a train with five functions: an odd number. Trains with an odd length are always 
  composed of length-3 trains, and they themselves are composed the same way as subject expressions: an odd-length
  train can be placed in the last position of another train without parentheses, but it needs parentheses to go 
  in any other position.\"
\"The example above uses a train with five functions: an odd number. Trains with an odd length are alw[...]other position.\"
"
m ← m map:with "io:writeCsv" "
  (filepath) io:writeCsv (array)

  Write array into CSV. Array must be 2-dimensional. All values written into CSV will be strings.


  \"test.txt\" io:writeCsv 2 4⍴⍳8         io:readFile \"test.txt\" 
┌→──────┐                               \"\"0\",\"1\",\"2\",\"3\"
↓0 1 2 3│                               \"4\",\"5\",\"6\",\"7\" 
│4 5 6 7│                               \"  
└───────┘
"
m ← m map:with "io2" "

  io2 namespace features experimental new input/output functions. The functions in the io2 namespace is a work in progress, 
  and eventually they will become the new standard I/O API. Streams abstract different ways to input and output: whether the 
  stream is a file, a web page, or the screen shouldn't matter. All that matters is that you receive information from the 
  stream (or send information into that stream.)

  io2:arrayStream   Create a stream from an array
  io2:exec   Execute shell command
  io2:flush  Empty open output stream
  io2:lines  
  io2:open   Open a stream
  io2:read   Read from a stream
  io2:readLine   Read line from a stream
  io2:write   Write to a stream
"
m ← m map:with "io2:arrayStream" "
  io2:arrayStream (bytearray)

  Create a stream from an array. Given a byte array, returns a stream which returns the data from the byte array.
  bytearray is the output of unicode:enc, an array of integers that have value between 0-255. If the argument is
  a string, unicode:enc is called on it to produce a byte array.

  
  io2:arrayStream \"foo\\ntest\" 
binary input stream
"
m ← m map:with "io2:exec" "
  io2:exec (stringarray)

  Execute a shell command. The right argument is an array of strings that contain the command and its parameters.
  io2:exec executes the command and returns its output as stream.


  p ← io2:exec \"sh\" \"-c\" \"echo test ; sleep 2 ; exit 4\"
  ⎕pl io2:readLine p⍠:stream :stdout
  ⎕p \"Waiting for exit\"
  code ← p⍠:waitForExit ¯1
  ⎕p \"Code: \" code
test
Waiting for exitCode: 4
"
m ← m map:with "io2:flush" "
  io2:flush (outputstream)

  Flushes the output stream and forces any buffered output bytes to be written out. If any bytes previously 
  written have been buffered by the implementation of the output stream, such bytes should immediately be 
  written to their intended destination. 


  out←io2:open⟦\"test.txt\"; :output⟧
binary output stream
  io2:write⟦out; \"yeah we streamin\"⟧  
⍬
  io2:flush out
⍬
  close out
binary output stream
"
m ← m map:with "io2:write" "
  io2:write⟦stream; data⟧  

  Write data to a stream. The first argument is a stream, and the second argument is the data to be written. 
  If the data is a string, it’s converted to binary by encoding using UTF-8 prior to writing. For binary data, 
  the argument must be a scalar or a single-dimensional array of integers, where each integer must be in the 
  range 0 to 255.


  out←io2:open⟦\"test.txt\"; :output⟧
binary output stream
  io2:write⟦out; \"yeah we streamin\"⟧  
⍬
  io2:flush out
⍬
  close out
binary output stream
"
m ← m map:with "io2:lines" "
  io2:lines (inputstream)

  Read the stream into an array line by line. 


  io2:lines io2:arrayStream \"<html><body>Foo<table><thead>
  <th>Foo</th><th>Bar</th></thead><tbody>
  <tr><td>1</td><td>10</td></tr><tr><td>abctest</td>
  <td>123foo</td></tr><tr><td>2</td><td>3</td></tr>
  </tbody></table></body></html>\"
┌→──────────────────────────────────────────────────────────────────────...─┐
│<html><body>Foo<table><thead>  <th>Foo</th><th>Bar</th></thead><tbody> ... |
└───────────────────────────────────────────────────────────────────────...─┘
"
m ← m map:with "io2:open" "
  io2:open⟦filepath; direction⟧ 

  Opens a stream as a file. The first argument is a file name that specifies which file to open. 
  The optional second argument is a list of keywords that indicate how the file is to be opened. 
  The following flags are accepted:

    :input — The file is opened for input.
    :output — The file is opened for output.

  The default option is :input.

  The resulting stream must be closed after being used. See close for more information.


  out←io2:open⟦\"test.txt\"; :output⟧
binary output stream
"
m ← m map:with "io2:read" "
  io2:read⟦stream; maxbytes⟧

  Read binary data from a stream. The first argument is the stream to read from. If no second argument given, 
  the entire content is read. If a second argument is provided, it must be an integer indicating the maximum 
  number of bytes to read.


  stream←io2:arrayStream \"<html><body>Foo<table><thead><th>Foo</th><th>Bar</th></thead><tbody>
  <tr><td>1</td><td>10</td></tr><tr><td>abctest</td><td>123foo</td></tr><tr><td>2</td><td>3</td></tr>
  </tbody></table></body></html>\"
binary input stream
   ⊣ io:println unicode:dec io2:read⟦stream; 42⟧
<html><body>Foo<table><thead><th>Foo</th><
"
m ← m map:with "io2:readLine" "
  io2:readLine (stream)

  Reads data up until the next newline or the end of the stream, and returns the string. If an end of file 
  condition was seen before any data was read, the function returns null.


  stream←io2:arrayStream \"<html><body>Foo<table><thead><th>Foo</th><th>Bar</th></thead><tbody>
  <tr><td>1</td><td>10</td></tr><tr><td>abctest</td><td>123foo</td></tr><tr><td>2</td><td>3</td></tr>
  </tbody></table></body></html>\"
binary input stream  
  ⊣ io:println io2:readLine stream
<html><body>Foo<table><thead><th>Foo</th><th>Bar</th></thead><tbody>
"
m ← m map:with "io2:write" "
  io2:write⟦outputstream; data⟧  

  Write data to a stream. The first argument is a stream, and the second argument is the data to be written. 
  If the data is a string, it’s converted to binary by encoding using UTF-8 prior to writing. For binary data, 
  the argument must be a scalar or a single-dimensional array of integers, where each integer must be in the 
  range 0 to 255.


  out←io2:open⟦\"test.txt\"; :output⟧
binary output stream
  io2:write⟦out; \"yeah we streamin\"⟧  
⍬
  io2:flush out
⍬
  close out
binary output stream
"
m ← m map:with "http" "

  http namespace contains functions for sending HTTP requests. The http functions all return a 3 element list 
  containing the following values:

    The HTTP status code

    The content, either as an array of characters or an array of bytes, depending on the content-type

    The response headers, represented as a 2-dimensional array where the first column contains the header name, 
    and the second column contains a list of all values


  http:delete   send a DELETE request 
  http:get   send a GET request
  http:post   send a POST request 
  http:put   send a PUT request
  http:urlEscape   escape characters in URLs
"
m ← m map:with "http:delete" "
  http:delete (url)

  Performs an HTTP DELETE and returns the result. If the request is successful, there are several possible 
  successful response status codes: 

  204 No Content: the request was successful and no additional information needs to be sent back to the client
  200 OK: the request was successful and the response body includes a representation describing the outcome
  202 Accepted: the request has been accepted and will probably succeed, but the resource has not yet been deleted by the server


  ⊣ (code ; data ; headers) ← http:delete \"https://google.com/search\"
  code     ⍝ 405 = method not allowed
405    
"
m ← m map:with "http:get" "
  http:get (url)
 
  Performs an HTTP GET request and return the result. The GET HTTP method requests a representation of the 
  specified resource. Requests using GET should only be used to request data and shouldn't contain a body.

  
  ⊣ (code ; data ; headers) ← http:get \"https://google.com/\"  
  code     ⍝ 200 = request OK
200
"
m ← m map:with "http:post" "
  http:post⟦url; headers; input⟧

  Performs an HTTP POST and returns the result. The POST HTTP method sends data to the server. The type of the 
  body of the request is indicated by the Content-Type header. The difference between PUT and POST is that PUT 
  is idempotent: calling it once is no different from calling it several times successively (there are no side 
  effects). Successive identical POST requests may have additional effects, such as creating the same order 
  several times.  


  ∇ gemini query {
    ⍝ curl with your apikey to see the list of models:
    ⍝  https://generativelanguage.googleapis.com/v1beta/models?key=AI...
    model ← \"gemini-2.5-flash-preview-05-20\"
    url ← \"https://generativelanguage.googleapis.com/v1beta/models/\", model, \":generateContent?key=\"
    apikey ← \"AI..................................VyY\" ⍝ your API key goes here
    target_url ← url, apikey
    input ← \"{\\\"contents\\\":[{\\\"parts\\\":[{\\\"text\\\":\\\"\", query, \"\\\"}]}]}\"
    headrs ← \"Accept\" \"application/json\"
    (code ; data ; headers) ← http:post⟦target_url; headrs; input⟧
    json ← json:readString data
    if (code=200) { → json.(\"candidates\").(0).(\"content\").(\"parts\").(0).(\"text\") } else {
       throw \"Error: \",⍕code
    }
  }
  ⍝ and to try it out
  gemini \"querying from the Kap language, hi there!\"
"
m ← m map:with "http:put" "
  http:put⟦url; headers; input⟧ 

  Performs an HTTP PUT request and returns the result. The PUT HTTP method creates a new resource or replaces 
  a representation of the target resource with the request content. The difference between PUT and POST is that 
  PUT is idempotent: calling it once is no different from calling it several times successively (there are no 
  side effects).

  
  url ← \"https://reqbin.com/echo/put/json\"
  headrs ← \"Content-Type\" \"application/json\"
  input ← {\\\"key1\\\":\\\"value\\\"}
  (code ; data ; headers) ← http:put⟦url; headers; input⟧ 
  json:readString data
┌Map: 8────────────────────────────────────────────────────────────────┐
│   args                                                       ┌Map: 0┐│
│                                                              │⍬     ││
│                                                              └──────┘│
│   data                                         {\"key1\" : \"value\"}│
│  files                                                       ┌Map: 0┐│
│                                                              │⍬     ││
│                                                              └──────┘│
........................................................................
│    url                                        https://httpbin.org/put│
└──────────────────────────────────────────────────────────────────────┘
"
m ← m map:with "httpserver" "
  http:urlEscape (urlstring)

  Escape characters in URLs. URL encoding converts characters into a format that can be transmitted over 
  the Internet. URLs can only be sent over the Internet using the ASCII character-set. Since URLs often 
  contain characters outside the ASCII set, the URL has to be converted into a valid ASCII format. 
  URLs cannot contain spaces. Kap URL encoding replaces percent sigh with =.


  http:urlEscape \"http://localhost:8080/foo?size=10&start=1000\"
\"http=3A=2F=2Flocalhost=3A8080=2Ffoo=3Fsize=3D10=26start=3D1000\"
"
m ← m map:with "httpserver" "
 
  httpserver namespace contains functions for managing the Kap HTTP server. Kap can serve webpages and 
  you are able to build many kinds of native web applications on top of it.

  httpserver:addHandler   Adds a handler to handle requests pointed at a specific url location
  httpserver:start   Start a webserver
"
m ← m map:with "httpserver:addHandler" "
  httpserver:addHandler⟦location; lambdafunction⟧

  Adds a handler to handle requests pointed at a specific url location. This handler function is called 
  every time a request is made to handler's location.


  ⍝ After running the below code, open http://localhost:8080/foo?size=10&start=1000 in a browser.
  ⍝ This will display an array with the specified dimensions in html form.  
  handler ⇐ {
      (size start) ← ⍵[:queryFields] map:get ⊂\"size\" ⊂\"start\"
      if (null ∊ size start) { throw \"Required parameters missing\" }  
      res ← (⍎start) + { (2 ⍴ ⍵) ⍴ ⍳⍵⋆2 } ⍎size
      map:with :headers (map:with \"Content-Type\" \"text/html\") `
          :data (\"\\n\\n\",(io:toHtml res),\"\\n\")
  }  
  httpserver:addHandler (\"/foo\" ; λhandler)
  httpserver:start ⍬
"
m ← m map:with "httpserver:start" "
  httpserver:start (args)

  Starts the HTTP server. The only argument you may give the function is 2-element array, (:port portnumber).
  The default port is 8080. Empty argument array starts server with default settings.


  ⍝ After running the below code, open http://localhost:8080/foo?size=10&start=1000 in a browser.
  ⍝ This will display an array with the specified dimensions in html form.
  handler ⇐ {
      (size start) ← ⍵[:queryFields] map:get ⊂\"size\" ⊂\"start\"
      if (null ∊ size start) { throw \"Required parameters missing\" }  
      res ← (⍎start) + { (2 ⍴ ⍵) ⍴ ⍳⍵⋆2 } ⍎size
      map:with :headers (map:with \"Content-Type\" \"text/html\") `
          :data (\"\\n\\n\",(io:toHtml res),\"\\n\")
  }
  httpserver:addHandler (\"/foo\" ; λhandler)
  httpserver:start ⍬
"
m ← m map:with "time" "

  time namespace contains functions for measuring, formatting and parsing time. 

  time:format   Format a timestamp
  time:fromTimestamp   Convert a timestamp object to an integer
  time:parse   Parse an ISO 8601 string
  time:runtime   Measure function execution times
  time:sleep   Pauses execution
  time:timeMillis   Get current time in milliseconds since Jan 1st 1970
  time:toTimestamp   Convert integer to a timestamp object
"
m ← m map:with "time:format" "
  time:format (timestamp)

  Format a timestamp object as an ISO 8601 UTC timestamp.


  time:format time:toTimestamp time:timeMillis 0
\"2025-10-28T00:28:03.703Z\"
"
m ← m map:with "time:fromTimestamp" "
  time:fromTimestamp (timestamp)

  Convert a timestamp object to an integer.


  datetime ← time:toTimestamp time:timeMillis 0
  time:fromTimestamp datetime
1761645118902
"
m ← m map:with "time:parse" "
  time:parse (utctimestamp)

  Parse an ISO 8601 string and return a timestamp object. Note that only UTC timestamps are supported.


  typeof time:parse \"2025-10-28T00:28:03.703Z\"
kap:timestamp
"
m ← m map:with "time:runtime" "
  time:runtime { ... }

  The code inside curly brackets will be executed, and before returning, the total runtime will 
  be printed to the standard output. The entire call returns the last evaluated expression.


  time:runtime { (≢⍕)¨ math:numerator«,»math:denominator { 3 + +/ ((¯1+⍵÷2) ⍴ 4 ¯4) ÷ ×/¨ , 0 ¯1 ↓ ¯1 2 ⍴ 3 ,/ 2+⍳⍵} 1e4 }
Total time: 6.647

┌→────────┐
│4347 4346│
└─────────┘
"
m ← m map:with "time:sleep" "
  time:sleep (seconds)

  Pauses the execution for the amount of seconds given as argument. Then returns the value of the 
  argument function.


  time:runtime { time:sleep 4 }
Total time: 4.0

4.0
"
m ← m map:with "time:timeMillis" "
  time:timeMillis 0

  Get current time in milliseconds since Jan 1st 1970 00:00:00. Returns an integer. 
  The function expects one argument which must be zero. The function cannot be called 
  without an argument or with a non-zero argument.


  time:timeMillis 0
1761647197281
"
m ← m map:with "time:toTimestamp" "
  time:toTimestamp (integer)

  Convert integer to a timestamp object. The argument is a number that has the same form as the return 
  value from time:timeMillis. The return value is a timestamp object.


  time:toTimestamp 12345678900
1970-05-23T21:21:18.900Z
"
m ← m map:with "sql" "

  sql namespace contains functions for connecting and querying SQL databases. The SQL API is currently 
  only supported with the JVM version of Kap. Structured Query Language (SQL) is a domain-specific 
  language used to manage data, especially in a relational database management system (RDBMS). It is 
  particularly useful in handling structured data, i.e., data incorporating relations among entities and 
  variables.   

  sql:connect   Connect to database
  sql:prepare   Prepare statement
  sql:query   Database query
  sql:queryPrepared   Perform query using prepared statement
  sql:update   Perform update query
  sql:updatePrepared   Perform update query using prepared statement 
"  
m ← m map:with "sql:connect" "
  sql:connect (connectionstring)

  Connect to an SQL database. This is a monadic function with the argument being a JDBC connection string. 
  Returns a connection handle. Connection should be closed with close (handle). You can create an in-memory 
  SQLite database by connecting to \"jdbc:sqlite:memory:\".

  To connect to an SQLite database:


  conn ← close atLeave sql:connect \"jdbc:sqlite:/path/to/database\"
Connection(url=jdbc:sqlite:/path/to/database)
  conn sql:query \"SELECT sql FROM sqlite_schema;\"
┌──────────────────────────────────────────────────┐
│                                               sql│
├→─────────────────────────────────────────────────┤
↓                            CREATE TABLE info (   │
│                            name TEXT NOT NULL,   │
│                            value TEXT NOT NULL,  │
│                            PRIMARY KEY (name))   │
│                                             null │
....................................................
│CREATE TABLE introductions (                      │
│book_number NUMERIC NOT NULL DEFAULT 0,           │
│introduction TEXT NOT NULL D[...] (book_number))  │
│                                              null│
└──────────────────────────────────────────────────┘
"
m ← m map:with "sql:prepare" "
  (connection) sql:prepare (query)
 
  Prepare parametrised SQL statement. The left argument is the connection, and the right is the SQL query. 
  Any positional parameters are specified using a ?, which can be later provided when calling queryPrepared 
  or updatePrepared. A prepared statement can be closed using the close function. If not closed, it will be 
  automatically closed when the connection is closed.


  conn ← close atLeave sql:connect \"jdbc:sqlite:memory:\"
  conn sql:update \"create table foo (a int primary key, b varchar(20))\"
  statement ← conn sql:prepare \"insert into foo values (?, ?)\"
  statement sql:updatePrepared 1 \"foo\"
  statement sql:updatePrepared 2 \"bar\"
  statement sql:updatePrepared 3 \"test message\"
  result ← conn sql:query \"select * from foo order by a\"
  close statement 
  close conn
  result
┌──┬──────────────┐
│ a│             b│
├→─┴──────────────┤
↓ 1          \"foo\"│
│ 2          \"bar\"│
│ 3 \"test message\"│
└─────────────────┘
"
m ← m map:with "sql:query" "
  (connection) sql:query (query)

  Send an SQL query to the database and return a table of the results. The left argument is an SQL 
  connection previously obtained using sql:connect, and the left argument is a string containing an 
  SQL statement. 


  conn ← close atLeave sql:connect \"jdbc:sqlite:/path/to/database\"
Connection(url=jdbc:sqlite:/path/to/database)
  conn sql:query \"SELECT sql FROM sqlite_schema;\"
┌──────────────────────────────────────────────────┐
│                                               sql│
├→─────────────────────────────────────────────────┤
↓                            CREATE TABLE info (   │
│                            name TEXT NOT NULL,   │
│                            value TEXT NOT NULL,  │
│                            PRIMARY KEY (name))   │
│                                             null │
....................................................
│CREATE TABLE introductions (                      │
│book_number NUMERIC NOT NULL DEFAULT 0,           │
│introduction TEXT NOT NULL D[...] (book_number))  │
│                                              null│
└──────────────────────────────────────────────────┘
"
m ← m map:with "sql:queryPrepared" "
  (statement) sql:queryPrepared (params)

  Executes a prepared SQL query. The left argument must be a statement previously returned from prepare. 
  The right argument must be a 1-dimensional array with a dimension equal to the number of positional 
  parameters in the prepared statement. Each value in the argument is assigned to the corresponding position 
  in the prepared statement and the query is executed. The result of the query is returned as per the query 
  function.


  c ← sql:connect \"jdbc:sqlite::memory:\"
  c sql:update \"create table foo (a int primary key, b varchar(20))\"
  c sql:update \"insert into foo values (1,'foo')\"
  c sql:update \"insert into foo values (2,'testing')\"
  c sql:update \"insert into foo values (3,'xx')\"
  c sql:update \"insert into foo values (4,'testing2')\"
  c sql:update \"insert into foo values (5,'testing-found')\"
  statement ← c sql:prepare \"select a, b from foo where a = ?\"
  result ← statement sql:queryPrepared ,5
  close statement
  close c
  result
┌─┬───────────────┐
│a│              b│
├→┴───────────────┤
↓5 \"testing-found\"│
└─────────────────┘
"
m ← m map:with "sql:update" "
  (connection) sql:update (query)
 
  Perform an SQL update operation (this includes delete, update, etc). The left argument is the connection, 
  and the right argument is the query string. Returns the number of rows affected.


  c ← sql:connect \"jdbc:sqlite::memory:\"
  c sql:update \"create table foo (a int primary key, b int null)\"
  c sql:update \"insert into foo (a,b) values (1,2)\"
  c sql:update \"insert into foo (a,b) values (2,null)\"
  res ← c sql:query \"select a,b from foo order by a\"
  close c
  res
┌─┬────┐
│a│   b│
├→┴────┤
↓1    2│
│2 null│
└──────┘
"
m ← m map:with "sql:updatePrepared" "
  (statement) sql:updatePrepared (array)

  Perform update query using prepared statement as one or more updates. If the right argument is of rank 1, 
  it performs a single update with arguments assigned as per queryPrepared. If the right argument is a 
  2-dimensional array, each row represents a single update, with the columns assigned to the positional 
  parameters in the prepared statement.


  conn ← close atLeave sql:connect \"jdbc:sqlite:/path/to/database\"
  statement ← sql:prepare \"insert info foo (a,b) values (?,?)\"
  statement sql:updatePrepared 3 2 ⍴ 12 23 34 45 56 67
  close statement
  res ← conn sql:query \"select * from foo\"
  close c
  res
┌──┬──────────────┐
│ a│             b│
├→─┴──────────────┤
↓ 1          \"foo\"│
│ 2          \"bar\"│
│ 3 \"test message\"│
│12           \"23\"│
│34           \"45\"│
│56           \"67\"│
└─────────────────┘
"
m ← m map:with "gui" "

  gui namespace contains functions pertaining to the Kap graphical user interface. 

  gui:create: Create graphics window
  gui:draw: Draw array
"
m ← m map:with "gui:create" "
  gui:create width height

  Creates a graphics window with width and height given as parameters. Returns a handle that you can use
  gui:draw with.


  screen ← gui:create 320 200
graphic-window
"
m ← m map:with "gui:draw" "
  (screen) gui:draw (arraydata)

  Draws on the window created with gui:create. You can keep drawing with some delay if you want to do 
  basic animation, but with JVM GUI it is recommended to use some function from Raylib to read the 
  keyboard to stop the animation.


  s←gui:create 200 200
graphic-window
  s gui:draw 20 < | { (0j1×⍵) +⌻ ⍵ } (⍳40)-20
┌→──────────────────────────────────────────────────────────────────────────────┐
↓1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1│
│1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1│
│1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1│
│1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1│
.................................................................................
│1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1│
│1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1│
│1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1│
│1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1│
└───────────────────────────────────────────────────────────────────────────────┘
"
m ← m map:with "labels" "
  (labelarray) labels[axis] (array)

  labels function is used to programmatically manage the axis labels for a given array. Once assigned, 
  the labels will be preserved by certain functions that preserve the general structure of an array. 
  Such functions include take, drop, reverse, etc. The idea is that the axes in the return value for 
  these functions can be interpreted to be the same as the ones in the input.

  Axis labels are used by the charting functions to label values. They are also used by the array editor 
  to display the names of the columns and rows.

  Monadic function: Get array axis labels. Return the labels for the given axis. The axis is specified as 
  an axis argument to the function. If no labels are assigned to an axis, a list of empty arrays are returned.

  labels[0] 1 2 3
┌→────┐
│⍬ ⍬ ⍬│
└─────┘


  Dyadic function: Assign axis labels. Given an N-dimensional array B, calling labels[M] with M being a valid 
  axis for B, return a new array where the labels for axis M is set to A. A must be a single-dimensional array 
  of the same size as the selected dimension in B.

  array ← \"abc\" \"def\" \"ghi\" labels[0] 3 3 ⍴ ⍳9
  labels[0] array
┌→────────────────┐
│\"abc\" \"def\" \"ghi\"│
└─────────────────┘
"
m ← m map:with "chart" "
  
  chart namespace contains functions for visualising data. Use the labels function to give axis labels to arrays.

  chart:bar   Display bar chart
  chart:line   Display line chart
  chart:pie   Display pie chart
  chart:plot  Function plot
  chart:scatter  Display scatter chart
"
m ← m map:with "chart:bar" "
  chart:bar (arraydata)

  Display data as bar chart. Input can be a 1- or 2-dimensional array of numbers. For 1-dimensional input, 
  each element is a single numeric value. For 2-dimensional input, the major axis represents each dataset, 
  with the second axis each value within that dataset. Each column is its own group in the chart, represented
  by a certain color for each row of data.


  chart:bar \"red\" \"yellow\" \"green\" labels[0] 3 4 ⍴ 3 5 3 7 6 1 10 12 7 10 11  
┌→─────────┐
↓3  5  3  7│
│6  1 10 12│
│7 10 11  3│
└──────────┘
"
m ← m map:with "chart:line" "
   chart:line (arraydata)

  Display data as line chart. The format of the input is the same as for chart:bar.


  chart:line \"Row1\" \"Row2\" \"Row3\" labels[0] \"Col1\" \"Col2\" \"Col3\" `
  labels[1] 3 3 ⍴ 1 2 2 3 3.5 2.6 5 6 3
┌────┬────┬────┐
│Col1│Col2│Col3│
├→───┴────┴────┤
↓   1    2    2│
│   3  3.5  2.6│
│   5    6    3│
└──────────────┘
"
m ← m map:with "chart:scatter" "
  chart:scatter (arraydata)

  Display data as scatter chart. A scatter chart is a set of X,Y coordinates along with an optional group. 
  The input is a 2-dimensional array with either 2 or 3 columns. The first two columns are the X and Y 
  coordinate respectively, with the third column being an identifier for the set. Each set is given a 
  different symbol on the chart.


  chart:scatter 5 3 ⍴ 0.3 2 \"Foo\" 1.5 1.75 \"Bar\" 2 3 \"Foo\" `
                      1   2 \"Abc\" 0.9 0.1  \"Abc\" 3 2 \"Abc\"
┌→─────────────┐
↓0.3    2  Foo │
│1.5 1.75  Bar │
│  2    3  Foo │
│  1    2  Abc │
│0.9  0.1  Abc │
└──────────────┘
"
m ← m map:with "chart:plot" "
  (from to) chart:plot (array of functions)
 
  The plot function is a dyadic function that accepts a two-element array as a left argument, and a function 
  or a list of functions as the right argument. The left argument represents the left and right edge of graph, 
  and the right argument being the functions to plot.


  0 10 chart:plot λ√ λ|  ⍝ plot y = abs(x) and y = sqrt(x)
⍬
"
m ← m map:with "maps" "

  A map contains a set of key/value pairs, where both the keys and values may be any Kap object.
  Values can be added, retrieved, and deleted using keys. Maps are immutable, in that their content 
  cannot be changed. Calling any of these functions always return a new map.

  map:with   Create or update a map
  map:get   Retrieve value from map with a key
  map:keys   Get an array of map keys
  map:remove   Remove a key-value pair from a map
  map:size   Get map size
  map:entries   Create an array out of a map
"
m ← m map:with "map:with" "
  map:with (keyvaluearray)

  Creates a new map. This function accepts a list of keys and values in one of two forms: 
  Either a 1-dimensional array containing an even number of elements. In this form, the keys 
  and values are interleaved as such: key0 value0 key1 value1, etc. The following expression 
  creates a map where the keys are strings and the values are lists of numbers:

  a ← map:with \"abc\" (1 2 3 4) \"def\" (5 6 7 8) \"ghi\" (9 10 11 12)

  It is also possible to specify the keys and values in a 2-dimensional array with 2 columns. 
  The following is identical to the previous example:

  a ← map:with \"abc\" (1 2 3 4) \"def\" (5 6 7 8) \"ghi\" (9 10 11 12)
┌Map: 3────────────┐
│ abc     ┌→──────┐│
│         │1 2 3 4││
│         └───────┘│
│ def     ┌→──────┐│
│         │5 6 7 8││
│         └───────┘│
│ ghi  ┌→─────────┐│
│      │9 10 11 12││
│      └──────────┘│
└──────────────────┘

  (map) map:with (keyvaluearray)

  Add new key-value pairs to a map. Maps are immutable, in that their content cannot be changed. To modify a map,
  use the functions map:with and mapRemove. These functions return a new map that contains the updated content.
  map:with accepts an existing map as the left argument, and a set of key/value pairs of the same form as was used
  in the map call, and returns a map where the new keys were added to the map, and any existing keys were replaced.


  aa ← map:with 1 \"first\" 2 \"second\"
┌Map: 2────┐
│1   first │
│2  second │
└──────────┘
  aa ← aa map:with 3 \"third\"
  aa
┌Map: 3────┐
│1   first │
│2  second │
│3   third │
└──────────┘
"
m ← m map:with "map:get" "
  (mapname) map:get (key)

  Retrieve map value corresponding to a key. The map is specified as the left argument and the key 
  on the right. The key needs to be enclosed with ⊂. Attempting to look up a nonexistent element 
  will return null.

  a ← map:with \"abc\" (1 2 3 4) \"def\" (5 6 7 8) \"ghi\" (9 10 11 12) 1 200
  a map:get ⊂1
200

  There are also two other ways of looking up values from a map. The array index syntax using square brackets 
  can be used, and works in a similar way to regular array indexing:

  a[\"abc\" \"def\"]
┌→──────────────────┐
│┌→──────┐ ┌→──────┐│
││1 2 3 4│ │5 6 7 8││
│└───────┘ └───────┘│
└───────────────────┘

  It is also possible to use period dereferencing. When using this method, only a single value may be looked 
  up, and if the key is missing, an error will be thrown.

    a.(\"ghi\")
┌→─────────┐
│9 10 11 12│
└──────────┘
"
m ← m map:with "map:remove" "
  (map) map:remove (keys)

  Remove key-value pairs from a map. map:remove accepts an existing map as the left argument, and a list of
  keys as the right argument. The function returns a new map where the specified keys were removed.


  aa                               aa ← aa map:remove ⊂1
┌Map: 3────┐                     ┌Map: 2────┐
│1   first │                     │2  second │
│2  second │                     │3   third │
│3   third │                     └──────────┘
└──────────┘
"  
m ← m map:with "map:size" "
  map:size (map)

  Returns the number of key-value pairs.


  aa                             map:size aa
┌Map: 3────┐                   3  
│1   first │                     
│2  second │                     
│3   third │                     
└──────────┘
"
m ← m map:with "map:entries" "
  map:entries (map)

  Returns the map as an array. As array content is unordered, the order of the key/value pairs in this data 
  will usually be different from what was used when creating the map.


  aa                             map:entries aa
┌Map: 3────┐                   ┌→─────────┐   
│1   first │                   ↓1   first │  
│2  second │                   │2  second │  
│3   third │                   │3   third │  
└──────────┘                   └──────────┘
"
m ← m map:with "map:keys" "
  map:keys (array)

  Get the list of map keys as an array.


  aa                       map:keys aa
┌Map: 3────┐             ┌→────┐  
│1   first │             │1 2 3│  
│2  second │             └─────┘  
│3   third │               
└──────────┘               
"
m ← m map:with "ffi" "

  The ffi namespace contains functions for interfacing native libraries. The namespace
  contains functions to manage memory, load libraries and call functions in the
  libraries.

  ffi:allocBytes   Allocates a byte buffer
  ffi:callFunction   Calls a guest language function
  ffi:copyInto   Copy memory from buffer to another
  ffi:findFunction   Find functions from a shared library
  ffi:free   Free memory buffer
  ffi:loadLibrary   Loads a shared library
  ffi:readFrom   Reads from a pointer 
"
m ← m map:with "ffi:allocBytes" "
  ffi:allocBytes (integer)

  Allocate a byte buffer. Returns a handle that points to allocated buffer.


  buf ← ffi:allocBytes 100
[ffi-buffer]
"
m ← m map:with "ffi:callFunction" "
  (functionhandle) ffi:callFunction (argumentbuffer)
 
  Dyadic function: Call guest language function functionhandle with arguments in argumentbuffer.


  ((ffi:loadLibrary \"libc.so.6\") ffi:findFunction (\"puts\" ; :int ; :string)) ` 
                                   ffi:callFunction \"test string via ffi call\"
25
"
m ← m map:with "ffi:copyInto" "
  (targetbuffer) ffi:copyInto (sourcebuffer)

  Dyadic function: Copy bytes from source to target buffer. 
  Used to supply arguments when calling guest language functions.


  buf ← ffi:allocBytes 100
  buf ffi:copyInto (\"testfoo\"-@\0),0
  lib ← ffi:loadLibrary \"libc.so.6\"
  fn ← lib ffi:findFunction (\"puts\" ; :int ; :ptr)
  result ← fn ffi:callFunction buf
  ffi:free buf
  result
8
"
m ← m map:with "ffi:findFunction" "
  (libraryhandle) ffi:findFunction (functionname ; arguments)

  Dyadic function: Get a handle for the function to be called with given arguments. The function to be 
  called needs to be dynamically linked to the shared binary file in order to call it with correct 
  context and parameters. 
  Left argument is the already loaded shared library. Right argument indicates function name and its 
  argument types (in this case, int putc(int c, FILE *stream) wants an integer and a pointer to a stream).

  
  ((ffi:loadLibrary \"libc.so.6\") ffi:findFunction (\"puts\" ; :int ; :string))
[ffi-function]
"
m ← m map:with "ffi:free" "
  ffi:free (buffer)
  
  Free allocated memory buffer. 


  buf ← ffi:allocBytes 100
  buf ffi:copyInto (\"testfoo\"-@\0),0
  lib ← ffi:loadLibrary \"libc.so.6\"
  fn ← lib ffi:findFunction (\"puts\" ; :int ; :ptr)
  result ← fn ffi:callFunction buf
  ffi:free buf
  result
8
"
m ← m map:with "ffi:loadLibrary" "
  ffi:loadLibrary (filepath)

  Load a shared library. There is no need to give path if the file is found in some of the dynamic library 
  directories.


  ((ffi:loadLibrary \"libc.so.6\") ffi:findFunction (\"puts\" ; :int ; :string)) ` 
                                   ffi:callFunction \"test string via ffi call\"
25
"
m ← m map:with "ffi:readFrom" "
  (integer) ffi:readFrom (buffer)

  Dyadic function: Reads from a buffer, left argument indicates how many bytes and right argument 
  indicates buffer to be read from.


  buf ← ffi:allocBytes 100
  buf ffi:copyInto (\"testfoo\"-@\\0),0
  unicode:dec 8 ffi:readFrom buf
\"testfoo␀\"
"
m ← m map:with "jvm" "

  jvm namespace contains functions that are native to and related to JVM. Kap is written in Kotlin and 
  compiled to be run on the Java virtual machine. It is suggested that the classes that you work with 
  in Kap are compiled with the same JDK version as Kap is. Currently Kap supports JDK version 21.

  jvm:arrayGetElement                                   jvm:isJvmNull
  jvm:arrayLength                                       jvm:toJvmBoolean
  jvm:arraySetElement                                   jvm:toJvmByte
  jvm:callMethod                                        jvm:toJvmChar
  jvm:createArrayInstance                               jvm:toJvmDouble
  jvm:createInstance                                    jvm:toJvmFloat
  jvm:findClass                                         jvm:toJvmInt
  jvm:findConstructor                                   jvm:toJvmLong
  jvm:findField                                         jvm:toJvmShort
  jvm:findMethod                                        jvm:toJvmString
  jvm:findPrimitiveTypeClass
  jvm:fromJvm
  jvm:getField
  jvm:instanceOf
"
m ← m map:with "jvm:toJvmString" "
  jvm:toJvmString (string)

  Returns a Kap string as a JVM instance. 


  str ← jvm:toJvmString \"Java yeah yeah\"
Java yeah yeah
  typeof str
jvm:jvmInstance  
"
m ← m map:with "jvm:toJvmShort" "
  jvm:toJvmShort (number)

  Returns an instance of JVM's 16bit signed integer type.


  jvm:toJvmShort 1234
1234
"
m ← m map:with "jvm:toJvmLong" "
  jvm:toJvmLong (number)

  Returns an instance of JVM's 64bit signed integer type.


  long ← jvm:toJvmLong time:timeMillis 0
1761952833300
  typeof long
jvm:jvmInstance
"
m ← m map:with "jvm:toJvmInt" "
  jvm:toJvmInt (number)

  Returns an instance of JVM's 32bit signed integer type.


  jvm:toJvmInt 1234
1234
  jvm:toJvmInt time:timeMillis 0
Error at: 1:1: toJvmInt: Value does not fit in int: 1761953147250
"
m ← m map:with "jvm:toJvmFloat" "
  jvm:toJvmFloat (number)

  Returns an instance of JVM's 32bit floating point type.


  pi ← jvm:toJvmFloat 3.14159265359
3.1415927
"
m ← m map:with "jvm:toJvmDouble" "
  jvm:toJvmDouble (number)

  Returns an instance of JVM's 64bit floating point type.


  pi ← jvm:toJvmDouble 3.1415926535897932384626433832795028841971
3.141592653589793
"
m ← m map:with "jvm:toJvmChar" "
  jvm:toJvmChar (number)

  Returns an instance of JVM's unsigned 16bit integer type. Accepts only numerical arguments. 


  jvm:toJvmChar 123
{
  jvm:toJvmChar ↑unicode:enc \"a\"
a
"
m ← m map:with "jvm:toJvmByte" "
  jvm:toJvmByte (number)

  Returns an instance of JVM's signed 8bit integer type.


  jvm:toJvmByte 127
127
  jvm:toJvmByte 128
Error at: 1:1: toJvmByte: Value does not fit in byte: 128
  jvm:toJvmByte -127
-127
"
m ← m map:with "jvm:toJvmBoolean" "
  jvm:toJvmBoolean (boolean)

  Returns an instance of JVM's Boolean type.


  jvm:toJvmBoolean 1
true
  jvm:toJvmBoolean 0
false
"
m ← m map:with "jvm:isJvmNull" "
  jvm:isJvmNull (variable)

  Returns true if variable is an instance of JVM's Null.


  jvm:isJvmNull 1
0
  jvm:isJvmNull 12
0
  jvm:isJvmNull null
1
"
m ← m map:with "jvm:instanceOf" "
  jvm:instanceOf⟦variable; javaclass⟧

  Returns true if variable is an instance of given Java class.


  jvm:instanceOf⟦jvm:toJvmString \"abc\" ; jvm:findClass \"java.lang.String\"⟧
1
"
m ← m map:with "jvm:findClass" "
  jvm:findClass (classstring)

  Return a Kap Java class handle. The given argument is the full package name of the Java class.
  Classes in Kap are looked up according to the classpath given to Kap at startup (see the build.gradle file).


  objectClass ← jvm:findClass \"java.lang.Object\"
class java.lang.Object
  stringClass ← jvm:findClass \"java.lang.String\"
class java.lang.String
  fileClass ← jvm:findClass \"java.io.File\"
class java.io.File
  typeof fileClass
jvm:jvmInstance  
"
m ← m map:with "jvm:findConstructor" "
  jvm:findConstructor⟦class; constructorargs⟧

  Returns a constructor handle. The arguments are the class whose constructor is being searched, and the types
  that the constructor takes as an argument. If the constructor takes no arguments: jvm:findConstructor⟦class⟧


  ⍝ java.io.file constructor: File(String pathname)
  fileClass ← jvm:findClass \"java.io.File\"
  stringClass ← jvm:findClass \"java.lang.String\"
  fileConstructor ← jvm:findConstructor⟦fileClass; stringClass⟧
public java.io.File(java.lang.String)
  ⍝ java.io.ByteArrayInputStream constructor: ByteArrayInputStream(byte[] buf)
  baisClass ← jvm:findClass \"java.io.ByteArrayInputStream\"
  baisConstructor ← jvm:findConstructor⟦baisClass; jvm:findPrimitiveTypeClass 'jvm:byteArray⟧
public java.io.ByteArrayInputStream(byte[])  
"
m ← m map:with "jvm:createInstance" "
  jvm:createInstance⟦constructor; constructorargs⟧

  Creates an instance of Java class with the constructor that has been defined with jvm:findConstructor.
  If the constructor does not take any arguments, they can be left out.


  path ← \"../classes\" ⍝ relative classpath root, has subdirs /com/example/test
  fullpath ← { ~(\"/\" ∊ ¯1↑⍵) → ⍵←⍵, \"/\" } path ⍝ append / if missing
  fileClass ← jvm:findClass \"java.io.File\"
  stringClass ← jvm:findClass \"java.lang.String\"
  fileConstructor ← jvm:findConstructor⟦fileClass; stringClass⟧  
  filePathObj ← jvm:createInstance⟦fileConstructor; fullpath⟧
../classes
"
m ← m map:with "jvm:getField" "
  jvm:getField⟦fieldhandle; instance⟧

  Returns the field value of a given class instance. fieldhandle is given by jvm:findField. 
  Instance can be null if no instance exists (like in the case of uninstantiable classes).


  path ← \"../classes\" ⍝ relative classpath root, has subdirs /com/example/test
  fullpath ← { ~(\"/\" ∊ ¯1↑⍵) → ⍵←⍵, \"/\" } path ⍝ append / if missing
  fileClass ← jvm:findClass \"java.io.File\"
  stringClass ← jvm:findClass \"java.lang.String\"
  fileConstructor ← jvm:findConstructor⟦fileClass; stringClass⟧  
  filePathObj ← jvm:createInstance⟦fileConstructor; fullpath⟧
  jvm:getField⟦jvm:findField⟦fileClass; \"pathSeparator\"⟧; filePathObj⟧
:
"
m ← m map:with "jvm:findField" "
  jvm:findField⟦class; fieldstring⟧

  Returns a field handle of a certain object field. You can use jvm:getField to retrieve field value.


  mathClass ← jvm:findClass \"java.lang.Math\"
  piField ← jvm:findField⟦mathClass; \"PI\"⟧
public static final double java.lang.Math.PI
  pi ← jvm:getField⟦piField; null⟧
3.141592653589793
"
m ← m map:with "jvm:findMethod" "
  jvm:findMethod⟦class; methodstring; methodarguments⟧

  Returns a method handle of a certain class. You must use it before jvm:callMethod.
  methodarguments is an optional list of types the method accepts as arguments. 


  mathClass ← jvm:findClass \"java.lang.Math\"
  random ← jvm:findMethod⟦mathClass; \"random\"⟧
public static double java.lang.Math.random()  
  jvm:callMethod⟦random; null⟧
0.42273426710832074
"
m ← m map:with "jvm:findPrimitiveTypeClass" "
  jvm:findPrimitiveTypeClass (typesymbol)

  Returns a JVM instance of JVM primitives, to be used with jvm:findConstructor. 
  The argument is given as a quoted symbol. Possible values are:
  'jvm:byte, 'jvm:short, 'jvm:int, 'jvm:long, 'jvm:float, 'jvm:double, 'jvm:boolean, 'jvm:char


  jvm:findPrimitiveTypeClass 'jvm:int
int
  typeof jvm:findPrimitiveTypeClass 'jvm:int
jvm:jvmInstance
"
m ← m map:with "jvm:getField" "
  jvm:getField⟦fieldhandle; fieldstring⟧

  Returns the field value of a certain object field. The fieldhandle argument is given by jvm:findField.


  mathClass ← jvm:findClass \"java.lang.Math\"
  piField ← jvm:findField⟦mathClass; \"PI\"⟧
public static final double java.lang.Math.PI
  pi ← jvm:getField⟦piField; null⟧
3.141592653589793
"
m ← m map:with "jvm:fromJvm" "
  jvm:fromJvm (value)

  The JVM functions return JVM instances. To use JVM function return value in Kap, it must be 
  converted to a Kap data type. This is done with jvm:fromJvm


  mathClass ← jvm:findClass \"java.lang.Math\"
  piField ← jvm:findField⟦mathClass; \"PI\"⟧
  pi ← jvm:getField⟦piField; null⟧
3.141592653589793
  typeof pi 
jvm:jvmInstance
  typeof jvm:fromJvm pi
kap:float
"
m ← m map:with "jvm:createArrayInstance" "
  jvm:createArrayInstance⟦class; numberofelements⟧

  jvm:createArrayInstance is used to create JVM array instances of type class[]. This is used, for example, 
  with constructors when the constructor expects an array of certain classes as argument.


  ⍝ an empty URL[10] array
  myUrls ← jvm:createArrayInstance⟦jvm:findClass \"java.net.URL\"; 10⟧
[Ljava.net.URL;@196df9fa
"
m ← m map:with "jvm:callMethod" "
  jvm:callMethod⟦methodhandle; instance; arguments⟧    

  Call a method of an instance. methodhandle is given by jvm:findMethod. instance is an instantiated 
  class (can be null). arguments are the arguments given to the method, each of them as a list element.


  path ← \"../classes\" ⍝ relative classpath root, has subdirs /com/example/test
  className ← \"com.example.test.TestClass\"
  fullpath ← { ~(\"/\" ∊ ¯1↑⍵) → ⍵←⍵, \"/\" } path
  fileClass ← jvm:findClass \"java.io.File\"
  stringClass ← jvm:findClass \"java.lang.String\"
  fileConstructor ← jvm:findConstructor⟦fileClass; stringClass⟧
  filePathObj ← jvm:createInstance⟦fileConstructor; fullpath⟧
  toURI ← jvm:findMethod⟦fileClass; \"toURI\"⟧
  uri ← jvm:callMethod⟦toURI; filePathObj⟧
file:/home/user/kap/array/gui/../classes/
"
m ← m map:with "jvm:arraySetElement" "
  jvm:arraySetElement⟦arrayinstance; index; element⟧

  Insert an element into a JVM array of type class[]. arrayinstance is the return value of 
  jvm:createArrayInstance, index is the slot to be filled and element is an instance of the 
  class in class[].


  myFiles ← jvm:createArrayInstance⟦jvm:findClass \"java.io.File\"; 10⟧
  path ← \"/classes/\"
  fileClass ← jvm:findClass \"java.io.File\"
  stringClass ← jvm:findClass \"java.lang.String\"
  fileConstructor ← jvm:findConstructor⟦fileClass; stringClass⟧
  filePathObj ← jvm:createInstance⟦fileConstructor; path⟧
  jvm:arraySetElement⟦myFiles; 0; filePathObj⟧
⍬
"
m ← m map:with "jvm:arrayLength" "
  jvm:arrayLength (jvmarray)

  Returns the size of the allocated array instance. The returned size is the same as what 
  jvm:createArrayInstance is given as argument.


  myFiles ← jvm:createArrayInstance⟦jvm:findClass \"java.io.File\"; 10⟧
[Ljava.io.File;@17960aff
  jvm:arrayLength myFiles
10
"
m ← m map:with "jvm:arrayGetElement" "
  jvm:arrayGetElement⟦jvmarray; index⟧

  Retrieves an element from JVM array at given index. Returns null if no element is found.


  jvm:arrayGetElement⟦myFiles; 1⟧
null
  jvm:arrayGetElement⟦myFiles; 0⟧
../classes
  typeof jvm:arrayGetElement⟦myFiles; 0⟧
jvm:jvmInstance
"                               
m ← m map:with "int" "
  
  int namespace is reserved for Kap internal functions. The contents of the namespace are subject to change.

  For more information, please see 
  https://codeberg.org/loke/array/src/branch/master/array/src/commonMain/kotlin/com/dhsdevelopments/kap/engine.kt

"
m ← m map:with "msoffice" "

  msoffice namespace contains functions for Microsoft Office interoperation. You can do the same with Kap's Array 
  Editor. In the GUI, click Window -> Array Editor, then in the editor click File -> Open to open an Excel file.
  You can give the opened data a name and click Put. You will now be able to use given name as any other regular array.

  msoffice:read   Read MSOffice file 
  msoffice:write   Write to MSOffice file
"
m ← m map:with "msoffice:read" "
  msoffice:read (filepath)

  Read an Excel file. filepath is a string containing path and filename.


  table←msoffice:read \"../test.xlsx\"
┌→──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
↓  0.0   1.0   2.0   3.0   4.0   5.0   6.0   7.0   8.0   9.0  10.0  11.0  12.0  13.0  14.0  15.0  16.0  17.0  18.0  19.0│
│ 20.0  21.0  22.0  23.0  24.0  25.0  26.0  27.0  28.0  29.0  30.0  31.0  32.0  33.0  34.0  35.0  36.0  37.0  38.0  39.0│
│ 40.0  41.0  42.0  43.0  44.0  45.0  46.0  47.0  48.0  49.0  50.0  51.0  52.0  53.0  54.0  55.0  56.0  57.0  58.0  59.0│
│ 60.0  61.0  62.0  63.0  64.0  65.0  66.0  67.0  68.0  69.0  70.0  71.0  72.0  73.0  74.0  75.0  76.0  77.0  78.0  79.0│
.........................................................................................................................
│200.0 201.0 202.0 203.0 204.0 205.0 206.0 207.0 208.0 209.0 210.0 211.0 212.0 213.0 214.0 215.0 216.0 217.0 218.0 219.0│
│220.0 221.0 222.0 223.0 224.0 225.0 226.0 227.0 228.0 229.0 230.0 231.0 232.0 233.0 234.0 235.0 236.0 237.0 238.0 239.0│
└───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
"
m ← m map:with "msoffice:write" "
  (filepath) msoffice:write (data)

  Dyadic function: Write data into Microsoft Excel file. filepath is a string containing path and filename.
  data is the data to be written into the file.


  \"../asdf.xlsx\" msoffice:write (2 2⍴⍳4)
┌→──┐
↓0 1│
│2 3│
└───┘
"
m ← m map:with "net" "

  net namespace contains functions for interfacing with communication endpoints (TCP sockets).

  net:connect   Create an endpoint for communication
  net:input   Accept data from endpoint
  net:output   Send data to endpoint
"
m ← m map:with "net:connect" "
  net:connect⟦domainname; portnumber⟧  

  Create an endpoint for communication. domainname is a string that can be IP address too. port is integer.


  conn ← net:connect⟦\"0.0.0.0\"; 5555⟧
[connection:host=127.0.0.53,port=5555]
"
m ← m map:with "net:input" "
  net:input⟦connection⟧  

  Receive communication from endpoint. connection is the endpoint opened up with net:connect. 
  Connection will remain open until it's closed from remote side or locally. use io2:readLine to
  read the stream line by line.

  
  conn ← net:connect⟦\"127.0.0.1\"; 5555⟧
[connection:host=127.0.0.1,port=5555]
  inputstream ← net:input⟦conn⟧
binary input stream
  io2:readLine inputstream
\"hello sir␍\"
"
m ← m map:with "net:output" "
  net:output⟦connection; data⟧  

  Send communication to endpoint. connection is the endpoint opened up with net:connect. data is encoded binary.
  Connection will remain open until it's closed from remote side or locally. use io2:write to
  write to the stream line by line.

  
  conn ← net:connect⟦\"127.0.0.1\"; 5555⟧
[connection:host=127.0.0.1,port=5555]
  inputstream ← net:input⟦conn⟧
binary input stream
  io2:readLine inputstream
\"hello sir␍\"
  outputstream ← net:output⟦conn⟧
binary output stream  
  io2:write⟦outputstream; \"yeah we read you loud and clear\"⟧  
⍬
"
m ← m map:with "o3" "

  The o3 namespace contains functions pertaining to printing and formatting Kap data.

  This namespace exports functions for use by users:

  o3:format Formats an object for display on the repl
  o3:show   Print a debug message

  The following variables contains data that can be used to control the
  way objects are rendered:

  o3:arrayMaxWidth   Controls horizontal trimming of displayed objects
  o3:arrayMaxHeight  Controls vertical trimming of displayed objects
"
m ← m map:with "o3:alignCells" "
  o3:alignCells (array)

  Prints Kap array with cells aligned to the right.


  o3:alignCells 2 3 ⍴100 2 3203948 4 5
┌→──────────────────┐
↓┌→──┐ ┌→┐ ┌→──────┐│
│↓100│ ↓2│ ↓3203948││
│└───┘ └─┘ └───────┘│
│  ┌→┐ ┌→┐     ┌→──┐│
│  ↓4│ ↓5│     ↓100││
│  └─┘ └─┘     └───┘│
└───────────────────┘
"
m ← m map:with "o3:isEnclosedArray" "
  o3:isEnclosedArray (array)

  Returns true if the argument array is enclosed.


  o3:isEnclosedArray 1 2 3
0
  o3:isEnclosedArray (1 2 3)
0
  o3:isEnclosedArray ⊂(1 2 3)
1
"
m ← m map:with "o3:renderChar" "
  o3:isEnclosedArray (char)

  Renders a single boxed character.


  o3:renderChar @g
┌→─┐
↓@g│
└──┘
  o3:renderChar \"J\"
┌→─┐
↓@J│
└──┘
"
m ← m map:with "o3:renderNumber" "
  o3:renderNumber (number)

  Renders a boxed number.


  o3:renderNumber 12345678
┌→───────┐
↓12345678│
└────────┘
  o3:renderNumber 1234 5678
┌→───────┐
↓12345678│
└────────┘
"
m ← m map:with "o3:renderRationalAsDecimal" "
  o3:renderRationalAsDecimal (rational)

  Renders a boxed decimal number out of a rational.


  a←1÷2
1/2
  typeof a
kap:rational
  o3:renderRationalAsDecimal a
┌→───┐
↓0.5r│
└────┘
"
m ← m map:with "o3:renderRationalAsDecimal" "
  o3:renderRationalWithFractionSlash (rational)

  Renders a boxed rational number with numerator and denominator separated by slash.


  a←1÷2
1/2
  typeof a
kap:rational
  o3:renderRationalWithFractionSlash a
┌→──┐
↓1⁄2│
└───┘
"
m ← m map:with "o3:renderSymbol" "
  o3:renderSymbol (symbol)

  Renders a boxed Kap symbol.


  o3:renderSymbol :KapSymbol
┌→─────────┐
↓:KapSymbol│
└──────────┘
"
m ← m map:with "o3:show" "
  o3:show (input)

  This function is identical to io:println. Print to standard output and return the given argument.


  o3:show 1÷2
1/2

1/2
"
m ← m map:with "o3:toHex" "
  o3:toHex (decimalnum)

  This command is identical to io:toHex. Returns argument in hexadecimal.


  o3:toHex 43962
\"ABBA\"
"
m ← m map:with "o3:toHex" "
   
  o3:withBorderAndTitle is a helper function used to render maps.

"
m ← m map:with "math" "

  math namespace contains functions for performing basic numeric operations such as the elementary exponential, 
  logarithm, square root, and trigonometric functions. 

  math:acos    Returns the arc cosine of a value   math:hypot Returns { √((⍺×⍺)+(⍵×⍵)) }
  math:acosh   Returns the hyperbolic arc cosine   math:im   Returns imaginary component
  math:asin   Returns the arc sine of a value      math:isPrime   Check if number is prime
  math:asinh   Returns the hyperbolic arc sine     math:lcm   Returns least common multiple
  math:atan   Returns the arc tangent of a value   math:numerator   Get the numerator of rat
  math:atanh   Returns the hyperbolic arc tangent  math:primes   Return all primes up to argument
  math:ceilc   Rounds up to the nearest integer    math:re   Returns real component
  math:cos   Returns the cosine of a value         math:round   Rounds to nearest integer
  math:cosh   Returns the hyperbolic cosine        math:sin   Returns the sine of a value
  math:denominator   Get the denominator of rat    math:sinh   Returns the hyperbolic sine 
  math:divisors   Returns divisors                 math:tan   Returns the tangent of a value
  math:factor   Factor into prime numbers          math:tanh   Returns the hyperbolic tangent
  math:floorc   Rounds down to nearest integer     math:pi   Returns approximate value of Pi
  math:gcd   Greatest common divisors              
"
m ← m map:with "math:pi" "
  math:pi

  Returns approximate value of Pi, the ratio of a circle's circumference to its diameter. 


  math:pi
3.141592653589793
"
m ← m map:with "math:acos" "
  math:acos (value)

  Returns the arc cosine of a value. The returned angle is in the range 0.0 through pi.


  math:acos 0.999
0.044725087168733454
  math:acos 0.000001
1.5707953267948966
  math:acos -0.3
1.8754889808102941
  math:acos -0.9
2.6905658417935308
"
m ← m map:with "math:acosh" "
  math:acosh (value)

  Returns the hyperbolic arc cosine of a value. Return value is in the range 1.0 through infinity.

  
  math:acosh 1
0
  math:acosh 2
1.3169578969248166
  math:acosh math:pi
1.8115262724608532
"
m ← m map:with "math:asin" "
  math:asin (value)

  Returns the arc sine of a value. Return value is in the range -pi÷2 through pi÷2.


  math:asin 1
1.5707963267948966
  math:asin 0
0.0
  math:asin ¯1
-1.5707963267948966
"
m ← m map:with "math:asinh" "
  math:asinh (value)

  Returns the hyperbolic arc sine of value. Return value is in the range -infinity through infinity.


  math:asinh -2000
-8.294049702602022
  math:asinh 0
0.0
  math:asinh 2000000
15.201804919084227  
"
m ← m map:with "math:atan" "
  math:atan (value)

  Returns the arc tangent of a value. Return value is in the range -pi÷2 through pi÷2.


  math:atan -10000
-1.5706963267952299
  math:atan 0
0.0
  math:atan 1000000
1.5707953267948966
"
m ← m map:with "math:atanh" "
  math:atanh (value)  

  Returns the hyperbolic arc tangent of value. Return value is in the range -1 through 1.


  math:atanh ¯1                   math:atanh 0.9
-Infinity                       1.4722194895832204  
  math:atanh ¯0.5                 math:atanh 0.999999
-0.5493061443340549             7.254328619247669
  math:atanh 0                    math:atanh 1
0.0                             Infinity
"
m ← m map:with "math:ceilc" "
  math:ceilc (value)

  Complex ceil, rounds up to the nearest integer.


  math:ceilc 1.23
2
  math:ceilc 0.0000000005
1.0
  math:ceilc 1.5J1.5
1.0J2.0
"
m ← m map:with "math:cos" "
  math:cos (value)

  Returns the cosine of a value. Return value is in the range -1 through 1.


  math:cos 0
1.0
  math:cos ¯1
0.5403023058681398
  math:cos 1
0.5403023058681398
  math:cos math:pi
-1.0
"
m ← m map:with "math:cosh" "
  math:cosh (value)

  Returns the hyperbolic cosine of a value. Return value is in the range 1 through infinity.


  math:cosh ¯1
1.543080634815244
  math:cosh 0
1.0
  math:cosh 1
1.543080634815244
  math:cosh 100
1.3440585709080678E43
"
m ← m map:with "math:denominator" "
  math:denominator (rational)

  Get the denominator of a rational.


  math:denominator (1÷20)
20
"
m ← m map:with "math:divisors" "
  math:divisors (integer)

  Returns divisors of an integer. An integer n is divisible by integer m if there exists an integer k such 
  that n = km. The function returns an array where the n:th value from the left times n:th value from the 
  right produces the argument. Primes don't have any divisors. Single element arrays are square roots of
  the given argument, so is the middle element in an odd-sized array.


  math:divisors 144 ⍝ 2×72 = 3×48 = 4×36 = ...
┌→───────────────────────────────┐
│2 3 4 6 8 9 12 16 18 24 36 48 72│
└────────────────────────────────┘
  math:divisors 12345 ⍝ 3×4115 = 5×2469 = ... 
┌→───────────────────┐
│3 5 15 823 2469 4115│
└────────────────────┘
"
m ← m map:with "math:factor" "
  math:factor (value)

  Returns the prime factors of a value. 


  math:factor 16
┌→──────┐
│2 2 2 2│
└───────┘
  math:factor 18
┌→────┐
│2 3 3│
└─────┘
  math:factor 12345
┌→──────┐
│3 5 823│
└───────┘
"
m ← m map:with "math:floorc" "
  math:floorc (value)

  Complex floor, rounds down to nearest integer.


  math:floorc 1.23
1.0
  math:floorc 0.9999
0.0
  math:floorc 1.5J1.5
2.0J1.0
"
m ← m map:with "math:gcd" "
  (value) math:gcd (value)

  Dyadic function: Returns the greatest common divisor between two values.


  60 math:gcd 1236
12
  823 math:gcd 12345
823
"
m ← m map:with "math:hypot" "
  (value) math:hypot (value)

  Dyadic function: Returns the hypothenuse if given two catheti of a right triangle as arguments.
  The function is the same as { √((⍺×⍺)+(⍵×⍵)) }


  5 math:hypot 12
13.0
"
m ← m map:with "math:im" "
  math:im (value)

  Returns the imaginary component of a value. 


  math:im 1
0
  math:im √¯1
1.0
  math:im math:acosh 0
1.5707963267948966  
"
m ← m map:with "math:isPrime" "
  math:isPrime (value)

  Returns 1 if value is a prime number. 


  math:isPrime 1.1
0
  math:isPrime 1
0
  math:isPrime 2
1
  math:isPrime 10196874914958288986107844413179268429561386007457
1
"
m ← m map:with "math:lcm" "
  (value) math:lcm (value)

  Returns the least common multiples between two values. The least common multiple (LCM) of two integers a and b, 
  is the smallest positive integer that is divisible by both a and b.


  4 math:lcm 6
12
  12 math:lcm 234
468
"
m ← m map:with "math:numerator" "
  math:numerator (rational)

  Get the numerator of a rational.


  math:numerator (5÷20)
5
"
m ← m map:with "math:primes" "
  math:primes (value)

  Return all primes up to argument.


  math:primes 123.4
┌→─────────────────────────────────────────────────────────────────────────────────────────┐
│2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113│
└──────────────────────────────────────────────────────────────────────────────────────────┘  
  (math:primes 123.4)~(math:primes 45.6)
┌→───────────────────────────────────────────────────┐
│47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113│
└────────────────────────────────────────────────────┘
"
m ← m map:with "math:re" "
  math:re (value)

  Returns the real component of a value.


  math:re 1
1
  math:re √¯1
6.123233995736766E-17
  math:re math:acosh 0
0.0
"
m ← m map:with "math:round" "
  math:round (value)

  Rounds value to nearest integer.


  math:round 123.4
123
  math:round 0.5
0
  math:round 0.55
1
"
m ← m map:with "math:sin" "
  math:sin (value)

  Returns the sine of a value. Return value is in the range -1 through 1.


  math:sin math:pi
1.2246467991473532E-16
  math:sin math:pi÷2
1.0
  math:sin √¯1
9.448643801263769E-17J1.1752011936438014
"
m ← m map:with "math:sinh" "
  math:sinh (value)

  Returns the hyperbolic sine of a value. Return value is in the range -infinity through infinity.


  math:sinh ¯10000
-Infinity
  math:sinh 0.9
1.0265167257081753
  math:sinh 10000
Infinity
"
m ← m map:with "math:tan" "
  math:tan  (value)

  Returns the tangent of a value. Return value is in the range -infinity through infinity.


  math:tan 1
1.5574077246549023
  math:tan 2
-2.185039863261519
  math:tan math:pi÷2
1.633123935319537E16
"
m ← m map:with "math:tanh" "
  math:tanh (value)

  Returns the hyperbolic tangent of a value. Return value is in the range -1 through 1.


  math:tanh ¯1000
-1.0
  math:tanh ¯1
-0.7615941559557649
  math:tanh 1
0.7615941559557649
  math:tanh 1000
1.0
"
m ← m map:with "objects" "

  objects namespace contains functions related to object oriented programming. In Kap, an object is a named
  entity that contain values. 

  objects:classof   Returns the object type
  objects:defclass   Defines a named object
  objects:extract   Get object values
  objects:make   Creates an object with values
"
m ← m map:with "objects:classof" "
  objects:classof (object)

  Returns the object type.


  class←objects:defclass 'foo
default:foo
  myObj←class objects:make 1 2
instance
  objects:classof myObj
default:foo
"
m ← m map:with "objects:defclass" "
  objects:defclass (symbolname)

  Defines an object type.


  class←objects:defclass 'foo
default:foo
  typeof class
kap:symbol
"
m ← m map:with "objects:make" "
  (class) objects:make (values)

  Dyadic function: Creates an object with given values.


  class←objects:defclass 'foo
default:foo
  myObj←class objects:make 1 2
instance
  objects:extract myObj
┌→──┐
│1 2│
└───┘
"
m ← m map:with "objects:extract" "
  objects:extract (object)

  Returns the values contained in an object. 


  class←objects:defclass 'foo
default:foo
  myObj←class objects:make 1 2
instance
  objects:extract myObj
┌→──┐
│1 2│
└───┘
"
m ← m map:with "valkey" "

  valkey namespace contains Kap Valkey bindings. Valkey is an open source high-performance key/value datastore that 
  supports a variety of workloads such as caching, message queues, and can act as a primary database. The project is 
  backed by the Linux Foundation, ensuring it will remain open source forever. You need to install Valkey separately,
  see https://valkey.io/topics/installation/

  valkey:connect   Connect to Valkey instance     valkey:hset   Creates or modifies the value of a field in a hash
  valkey:delete   Delete key                      valkey:incr   Increments the integer value of a key by one
  valkey:get   Get key the value of a key         valkey:keys   Returns all key names that match a pattern
  valkey:getObj   Get object corresponding to key valkey:set   Sets the string value of a key, ignoring its type
  valkey:gets   Returns the string value of a key valkey:setobj   Set object value of a key
  valkey:hget   Returns the value of a field in a hash
"
m ← m map:with "valkey:connect" "
  valkey:connect (domainname)

  Connect to Valkey instance at domainname. The argument can also be an ip address. Remember to close the connection.


  conn ← close atLeave valkey:connect \"127.0.0.1\"
[valkey hostname=127.0.0.1, port=6379]
"
m ← m map:with "valkey:delete" "
  (connection) valkey:delete (key)

  Dyadic function: Implements the DEL command. Returns 1 if operation was successful.
  

  conn ← close atLeave valkey:connect \"127.0.0.1\"
  conn valkey:set \"key1\" \"hello\"
  conn valkey:delete \"key1\"
1
  conn valkey:get \"key1\"
null
"
m ← m map:with "valkey:get" "
  (connection) valkey:get (key)

  Dyadic function: Implements the GET command. 


  conn ← close atLeave valkey:connect \"127.0.0.1\"
  conn valkey:set \"key1\" \"hello\"
  conn valkey:get \"key1\"
┌→──────────────────┐
│104 101 108 108 111│
└───────────────────┘
  unicode:dec conn valkey:get \"key1\"
\"hello\"
"
m ← m map:with "valkey:getobj" "
  (connect) valkey:getobj (key)

  Dyadic function: Get byte object corresponding to given key. Byte objects turn into Kap objects
  when retrieved.


  conn ← close atLeave valkey:connect \"127.0.0.1\"
  (code ; data ; headers) ← http:get \"https://kapdemo.dhsdevelopments.com/\"
  conn valkey:setobj \"headers\" headers
⍬
  conn valkey:getobj \"headers\"
┌Map: 9──────────────────────────────────────────────────────────────────────────────────────────┐
│            accept-ranges                                                              ┌→──────┐│
│                                                                                       │ bytes ││
│                                                                                       └───────┘│
│             cache-control  ┌→─────────────────────────────────────────────────────────────────┐│
│                            │ no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0 ││
│                            └──────────────────────────────────────────────────────────────────┘│
│                connection                                                        ┌→───────────┐│
│                                                                                  │ keep-alive ││
│                                                                                  └────────────┘│
..................................................................................................
│ strict-transport-security                               ┌→────────────────────────────────────┐│
│                                                         │ max-age=31536000; includeSubDomains ││
│                                                         └─────────────────────────────────────┘│
└────────────────────────────────────────────────────────────────────────────────────────────────┘
"
m ← m map:with "valkey:gets" "
  (connection) valkey:gets (key)

  Dyadic function: Get the value corresponging to a key as a string. Normally Valkey values are bytes, 
  so getting them as string means you don't have to call unicode:dec on the return value.


  conn ← close atLeave valkey:connect \"127.0.0.1\"
  conn valkey:set \"key1\" \"hello\"
  conn valkey:get \"key1\"
┌→──────────────────┐
│104 101 108 108 111│
└───────────────────┘
  conn valkey:gets \"key1\"
\"hello\"    
"
m ← m map:with "valkey:hset" "
  (connection) valkey:hset (key) (field-valuepair)

  Dyadic function: Set a field-value pairs in the hash. You can only give one field-value pair as argument.


  conn ← close atLeave valkey:connect \"127.0.0.1\"
  (conn) valkey:hset \"hashmap\" \"key\" \"value\"
1  
  (conn) valkey:hget \"hashmap\" \"key\"
┌→─────────────────┐
│118 97 108 117 101│
└──────────────────┘
  unicode:dec (conn) valkey:hget \"hashmap\" \"key\"
\"value\"
"
m ← m map:with "valkey:hget" "
  (connection) valkey:hget (hashmapkey) (fieldkey)

  Dyadic function: Retrieve value corresponding to fieldkey in a hashmap.


  conn ← close atLeave valkey:connect \"127.0.0.1\"
  (conn) valkey:hset \"hashmap\" \"key\" \"value\"
1  
  (conn) valkey:hget \"hashmap\" \"key\"
┌→─────────────────┐
│118 97 108 117 101│
└──────────────────┘
  unicode:dec (conn) valkey:hget \"hashmap\" \"key\"
\"value\"
"
m ← m map:with "valkey:incr" "
  (connection) valkey:incr (key)

  Dyadic function: Implemets the INCR function. Increments the integer value of a key by 1. The key that
  is incremented cannot have any other value before increment, it has to be created by calling 
  valkey:incr on it, thus giving it value 1.


  conn ← close atLeave valkey:connect \"127.0.0.1\"
  conn valkey:incr \"counter\"
1
  conn valkey:incr \"counter\"
2  
"
m ← m map:with "valkey:keys" "
  (connection) valkey:keys (pattern)

  Dyadic function: Implements the KEYS function. Returns all keys matching a pattern.


  conn ← close atLeave valkey:connect \"127.0.0.1\"
  conn valkey:set \"key1\" \"hello\"
  conn valkey:set \"key2\" \"world\"  
  conn valkey:keys \"key*\"
┌→────────────┐
│ key2   key1 │
└─────────────┘
"
m ← m map:with "valkey:set" "
  (connection) valkey:set (key) (value)

  Dyadic function: Implements the SET command. Sets key to hold the given value. 
  Returns \"OK\" if successful.
  

  conn ← close atLeave valkey:connect \"127.0.0.1\"
  conn valkey:set \"key1\" 1
\"OK\"  
  conn valkey:get \"key1\"
┌→┐
│1│
└─┘
"
m ← m map:with "valkey:setobj" "
  (connect) valkey:setobj (key) (value)

  Dyadic function: Set byte object to correspond to given key. Byte objects turn into Kap objects
  when retrieved.


  conn ← close atLeave valkey:connect \"127.0.0.1\"
  (code ; data ; headers) ← http:get \"https://kapdemo.dhsdevelopments.com/\"
  conn valkey:setobj \"headers\" headers
⍬
  conn valkey:getobj \"headers\"
┌Map: 9──────────────────────────────────────────────────────────────────────────────────────────┐
│            accept-ranges                                                              ┌→──────┐│
│                                                                                       │ bytes ││
│                                                                                       └───────┘│
│             cache-control  ┌→─────────────────────────────────────────────────────────────────┐│
│                            │ no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0 ││
│                            └──────────────────────────────────────────────────────────────────┘│
│                connection                                                        ┌→───────────┐│
│                                                                                  │ keep-alive ││
│                                                                                  └────────────┘│
..................................................................................................
│ strict-transport-security                               ┌→────────────────────────────────────┐│
│                                                         │ max-age=31536000; includeSubDomains ││
│                                                         └─────────────────────────────────────┘│
└────────────────────────────────────────────────────────────────────────────────────────────────┘
"
m ← m map:with "crypto:makeDigest" "
  crypto:makeDigest (digestalgo)

  Generates a hash digest for given message digest algorithm. digestalgo is one of these symbols:
  :SHA256 :SHA512 :MD5 :SHA1. To encode a binary message message, use ⍠


  d ← crypto:makeDigest :SHA256 
  d⍠:encode \"My secret message\"
┌→────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│61 145 66 47 205 206 208 12 48 11 8 4 139 224 140 26 43 159 75 82 187 48 121 40 214 210 230 197 35 119 34 241│
└─────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
"
m ← m map:with "mod" "
  
  mod namespace contains functions related to Kap modules. Kap is modular software and its functionality
  under various namespaces is provided in loadable modules. Dynamic loading of modules is not implemented.

  mod:list   Returns an array of loaded modules
  mod:load   NOT IMPLEMENTED
"
m ← m map:with "mod:list" "
  mod:list (null)

  Returns loaded modules. Since every function in Kap requires you to provide an argument, you need to give
  mod:list something. 


  mod:list null
┌→─────────────────────────────────────────────────────────────────────────────────────────...─────────┐
│ classloader-metamodule   cryptography   ffi   forms   fx-animation   gui   http-server   ...  valkey │
└──────────────────────────────────────────────────────────────────────────────────────────...─────────┘
"
m ← m map:with "mod:load" "
  mod:load (null)

  Load a module. Currently not implemented.

"
m ← m map:with "forms" "

  forms namespace contains functions for creating forms for inputting data. 
  See https://www.youtube.com/watch?v=rAMtwDvPrvo for a demo.

  forms:create   Create form 
  forms:read   Read form data
  forms:show   Open a form window
"
m ← m map:with "forms:create" "
  forms:create (formelements)

  Create a form with given elements. Form elements are given as array of field-value pairs of the form 
  (type field value)

  Types: :label      defines label element (no data input), can contain text in :text field
         :textField  defines a text field for user text input, can contain predefined text in :text field


  a ← forms:create (:label :text \"First name\") (:textField :key 'firstname) (:label :text \"Last name\") (:textField :key 'lastname) 
⍬
  forms:show a
  result ← forms:read a
╔════╤═══════════════════════════╗
║ OK │┌Map: 2───────────────────┐║
║    ││default:firstname  Hello │║
║    ││ default:lastname  World │║
║    │└─────────────────────────┘║
╚════╧═══════════════════════════╝  
"
m ← m map:with "forms:show" "
  forms:show (form)

  Open a new window displaying the form.


  a ← forms:create (:label :text \"First name\") (:textField :key 'firstname) (:label :text \"Last name\") (:textField :key 'lastname) 
⍬
  forms:show a
  result ← forms:read a
╔════╤═══════════════════════════╗
║ OK │┌Map: 2───────────────────┐║
║    ││default:firstname  Hello │║
║    ││ default:lastname  World │║
║    │└─────────────────────────┘║
╚════╧═══════════════════════════╝  
"
m ← m map:with "forms:read" "
  forms:read (form)

  Wait for user input and return data after it has been submitted. Control flow is returned back only after
  data has been submitted.


  a ← forms:create (:label :text \"First name\") (:textField :key 'firstname) (:label :text \"Last name\") (:textField :key 'lastname) 
⍬
  forms:show a
  result ← forms:read a
╔════╤═══════════════════════════╗
║ OK │┌Map: 2───────────────────┐║
║    ││default:firstname  Hello │║
║    ││ default:lastname  World │║
║    │└─────────────────────────┘║
╚════╧═══════════════════════════╝  
"
m ← m map:with "audio" "
 
  audio namespace contains functions related to audio control.

  audio:play   Play sample at 48kHz sampling frequency

"
m ← m map:with "audio:play" "
  audio:play (audiodata)

  Play sample at 48kHz sampling frequency. audiodata is an array of values between -1.0 and 1.0


  audio:play math:sin +\ 5000 / (300+50×⍳5) ÷ (48000.0÷math:pi×2)
⍬
"

helpBackend ⇐ {
    input ← " " regex:split ⍵
    item ← input[0]
    if ("search"≡⊃item) {
        {
            lookup ← ⍵
            rows ← map:entries man:m
            ord ← ⍒{ ≢(lookup regex:findall ⍵) }¨ rows[;1]
            short ← {⍵[0…60]}¨ rows[;1]
            r ← (⍪rows[;0]),(⍪short),(⊂"...\n\n")
            io:println (r[ord;])[0…4;]
        } (⊃input[1])
    } else {
        io:println man:m[input[0]]
    }
}

λhelpBackend

